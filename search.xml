<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据分析系统介绍</title>
      <link href="/2024/04/18/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/04/18/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><h2 id="什么是BI？"><a href="#什么是BI？" class="headerlink" title="什么是BI？"></a>什么是BI？</h2><p>BI是商业智能（Business Intelligence）的缩写。它是一种通过收集、分析和呈现数据来帮助企业做出更好决策的技术和过程。BI通常涉及使用各种数据仓库、数据挖掘和数据分析工具，以提取有关企业绩效、市场趋势、客户行为等方面的信息。这些数据可以被转化为可视化图表、报表和仪表盘，可协助企业管理层了解他们所运营的公司的情况，并根据这些信息制定更明智的商业决策。</p><p>类似于下图：</p><p><img src="https://img.wcw231407.cn/202404180924148.png" alt="商业"></p><blockquote><p>BI 商业智能：数据可视化，报表可视化系统</p><p>主流BI平台：帆软BI、小马BI、微软Power BI</p></blockquote><h2 id="传统BI平台："><a href="#传统BI平台：" class="headerlink" title="传统BI平台："></a>传统BI平台：</h2><p><a href="https://chartcube.alipay.com/export">https://chartcube.alipay.com/</a></p><p>1.需要人工上传数据</p><p>2.需要人工推选分析要用到的数据行和列（数据分析师）</p><p>3.需要人工选择图表类型（数据分析师）</p><p>4.生成图表（保存配置）</p><h2 id="本智能BI平台："><a href="#本智能BI平台：" class="headerlink" title="本智能BI平台："></a><strong>本智能BI平台</strong>：</h2><p>区别于传统的BI，用户（数据分析师），只需要导入最最最最原始的数据集，输入想要进行分析的目标（比如帮我分析一下网站的增长趋势），就能利用AI自动生成一个符合要求的图表以及结论。</p><p><strong>优点：让不会数据分析的用户也可以通过输入目标快速完成数据分析，大幅节约人力成本，将会用到 AI 接口生成分析结果</strong></p><p>会用到AI接口</p><h1 id="此项目的BI平台"><a href="#此项目的BI平台" class="headerlink" title="此项目的BI平台"></a>此项目的BI平台</h1><p>区别于传统的BI，用户（数据分析者）只需要导入最原始的数据集，输入想要进行分析的目标（比如帮我分析一下网站的增长趋势)，就能利用AI自动生成一个符合要求的图表以及分析结论。此外，还会有图表管理、异步生成等功能。</p><p><strong>优点：让不会数据分析的用户也可以通过输入目标快速完成数据分析，大幅节约人力成本，将会用到 AI 接口生成分析结果</strong></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a><strong>需求分析</strong></h2><p>1.智能分析：用户输入目标和原始数据（图标类型），可以自动生成图表和分析结论</p><p>2.图表管理</p><p>3.图表生成的异步化（消息队列）</p><p>4.对接AI能力</p><h2 id="项目架构图"><a href="#项目架构图" class="headerlink" title="项目架构图"></a>项目架构图</h2><h3 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h3><p>基础流程：客户端输入分析诉求和原始数据，向业务后端发送请求。业务后端利用AI服务处理客户端数据，保持到数据库，并生成图表。处理后的数据由业务后端发送给AI服务，AI服务生成结果并返回给后端，最终将结果返回给客户端展示。</p><blockquote><p>要根据用户的输入生成图标，借助AI服务</p></blockquote><p><img src="https://img.wcw231407.cn/202404180931376.png" alt="image-20240418093146287"></p><blockquote><p>上图的流程会出现一个问题：</p><p>假设一个 AI 服务生成图表和分析结果要等50秒，如果有大量用户需要生成图表，每个人都需要等待50秒，那么 AI 服务可能无法受这种压力。为了解决这个问题，可以采用消息队列技术。</p><p>这类以于在餐厅点餐时，为了避免顾客排队等待，餐厅会给顾客一个取餐号码，上顾客可以先去坐下或做其他事情，等到餐厅叫到他们的号码时再去领取餐点，这样就能节省等待时间。</p><p>同样地，通过消息队列，用户可以提交生成图表的请求，这些请求会进入队列，AI 服务会衣次处理队列中的请求，从而避免了同时处理大量请求造成的压力，同时也影更好地控制资源的使用。</p></blockquote><h3 id="优化流程"><a href="#优化流程" class="headerlink" title="优化流程"></a>优化流程</h3><p><img src="https://img.wcw231407.cn/202404180934814.png" alt="image-20240418093411720"></p><blockquote><p>优化流程（异步化）：客户端输入分析诉求和原始数据，向业务后端发送请求。业务后端将请求事件放入消息队列，并为客户端生成取餐号，让要生成图表的客户端去排队，消息队列根据I服务负载情况，定期检查进度，如果AI服务还能处理更多的图表生成请求，就向任务处理模块发送消息。</p><p>任务处理模块调用AI服务处理客户端数据，AI 服务异步生成结果返回给后端并保存到数据库，当后端的AI工服务生成完毕后，可以通过向前端发送通知的方式，或者通过业务后端监控数据库中图表生成服务的状态，来确定生成结果是否可用。若生成结果可用，前端即可获取并处理相应的数据，最终将结果返回给客户端展示。在此期间，用户可以去做自己的事情。</p></blockquote><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a><strong>技术栈</strong></h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a><strong>前端</strong></h3><p>1.React</p><p>2.Umi+Ant Design Pro</p><p>3.可视化开发库（Echarts+HighCharts+AntV）</p><p>4.umi openapi代码生成（自动生成后端调用代码）</p><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a><strong>后端</strong></h3><p>1.SpringBoot（万用Java后端模板，快速搭建基础框架，避免重复写代码）</p><p>2.MySQL数据库</p><p>3.MyBatis Plus数据访问框架</p><p>4.消息队列</p><p>5.AI能力</p><p>6.Excel的上传和数据的解析（Easy Excel）</p><p>7.Swagger + Knife4j项目接口文档</p><p>8.Hutool工具库</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2024/04/18/Ngnix/"/>
      <url>/2024/04/18/Ngnix/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a><strong>nginx</strong></h1><blockquote><p>公司产品出现瓶颈？</p></blockquote><p>我们公司项目刚刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户</p><p><img src="https://img.wcw231407.cn/202404180857981.png" alt="image-20240418085711867"></p><p>但是慢慢的，使用我们平台的用户多了，并发量慢慢慢增大了，这时候一台服务器满足不了我们的需求了</p><p><img src="https://img.wcw231407.cn/202404180858953.png" alt="image-20240418085800876"></p><p>于是我们横向扩展，又增加了服务器。这时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理访问器了，通过代理服务器来帮我们转发和处理请求</p><p><img src="https://img.wcw231407.cn/202404180858076.png" alt="image-20240418085815984"></p><p>我们希望这个代理服务器可以帮助我们接收用户请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望它可以按照服务器的性能提供不同权重的选择。保证最佳体验！所以我们使用了ngnix</p><p>直接访问服务器产生的问题：</p><p><img src="https://img.wcw231407.cn/202404180900332.png" alt="image-20240418090044247"></p><p>代理：</p><p><img src="https://img.wcw231407.cn/202404180901297.png" alt="image-20240418090106143"></p><blockquote><p>架构的核心精髓：没有什么是加一层解决不了的</p></blockquote><p>nginx反向代理的好处：</p><ul><li>提高访问速度</li><li>进行负载均衡</li><li>保证后端服务安全</li></ul><p>所谓负载均衡，就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器</p><h2 id="nginx是什么？"><a href="#nginx是什么？" class="headerlink" title="nginx是什么？"></a><strong>nginx是什么？</strong></h2><p><a href="https://m.baidu.com/s?word=Nginx&sa=re_dqa_zy">Nginx<em></em></a> 是一款高性能的 Web 服务器和反向代理服务器，同时支持 <a href="https://m.baidu.com/s?word=IMAP&sa=re_dqa_zy">IMAP<em></em></a>、<a href="https://m.baidu.com/s?word=POP3&sa=re_dqa_zy">POP3<em></em></a> 和 <a href="https://m.baidu.com/s?word=SMTP&sa=re_dqa_zy">SMTP<em></em></a> 服务。它的特点包括占用内存少和并发能力强，因此在高负载的情况下表现出色</p><h2 id="ngnix作用"><a href="#ngnix作用" class="headerlink" title="ngnix作用"></a><strong>ngnix作用</strong></h2><p>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理</p><h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a><strong>正向代理与反向代理</strong></h3><p>阿里云、腾讯云如何搭建局域网</p><p>答:默认情况下我们同一个用户购买几台服务器都是在同一个局域网内，不是同一个用户的服务器不是一个局域网下</p><p>正向代理（vpn）</p><p><img src="https://img.wcw231407.cn/202404180902858.png" alt="image-20240418090251746"></p><p>反向代理</p><p><img src="https://img.wcw231407.cn/202404180903639.png" alt="image-20240418090312499"></p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h3><p>ngnix提供的是负载均衡策略有两种：内置策略和扩展策略。内置策略为轮询、加权轮询、lp hash；扩展策略，就天马行空，只有你想不到没有它做不到</p><p><strong>轮询</strong></p><p><img src="https://img.wcw231407.cn/202404180903890.png" alt="image-20240418090355781"></p><p>权重都是1，每一个服务器循环请求一次</p><p><strong>加权轮询</strong></p><p><img src="https://img.wcw231407.cn/202404180904050.png" alt="image-20240418090425898"></p><p>权重高的接受更多的请求</p><p><strong>iphash对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理，可以解决session不问题。</strong></p><blockquote><p>但是如果存session的服务器挂了呢？那么所有信息都挂了，所有我们建议使用redis</p></blockquote><p><strong>动静分离</strong></p><p>动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件成为静态文件。让动态网站里的动态网址根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做好缓存操作。提高资源响应</p><p><strong>ngnix常用命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/ngnix/sbin/</span><br><span class="line">./ngnix  #启动</span><br><span class="line">./ngnix -s stop  #停止</span><br><span class="line">./ngnix -s reload  #重新加载配置文件</span><br><span class="line">ps aux|grep ngnix  #查看ngnix进程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-01</title>
      <link href="/2024/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98-01/"/>
      <url>/2024/04/15/%E9%9D%A2%E8%AF%95%E9%A2%98-01/</url>
      
        <content type="html"><![CDATA[<h1 id="1、JDK-和-JRE-和-JVM-分别是什么，有什么区别？"><a href="#1、JDK-和-JRE-和-JVM-分别是什么，有什么区别？" class="headerlink" title="1、JDK 和 JRE 和 JVM 分别是什么，有什么区别？"></a>1、JDK 和 JRE 和 JVM 分别是什么，有什么区别？</h1><p><strong>JDK（Java Development Kit，Java 软件开发工具包）</strong></p><p>JDK（Java Development Kit）：JDK 是 Java 开发⼯具包，包含了编写、编译、调试和运⾏ Java 程序所需的所有⼯具和组件（包含了JRE和一些java开发工具），⽐如编译器（javac）、Java API、调试⼯具等。JDK 是针对 Java 开发⼈员的，它包含了 JRE，还有编译器和其他⼯具，可以⽤来编写和调试 Java 程序。</p><p><strong>JRE（Java Runtime Environment，Java 运行环境）</strong></p><p>JRE 是 Java 运⾏时环境，包括了 Java 虚拟机（JVM）和 Java 标准类 库（Java API）。JRE 是针对 Java 应⽤程序的，它提供了在计算机上运⾏ Java 应⽤程序所需的最⼩环境。</p><p><strong>JVM（Java Virtual Machine，Java 虚拟机）</strong></p><p>JVM 是 Java 虚拟机，JVM是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。在Java虚拟机上⽣成可运⾏的字 节码，移植到在其他平台上时可不加修改地运⾏</p><p><strong>三者之间区别：</strong></p><p>​    1.JDK是Java开发工具包含了java运行环境和java开发工具</p><p>​    2.JRE是Java运行时环境，包括了java核心类库。</p><p>​    3.JVM是java环境（jre）的一部分，是跨平台核心部分，可运行java核心代码</p><blockquote><p>Java开发⼯具包&#x3D;Java 运⾏环境+Java开发⼯具</p><p>Java 运⾏环境&#x3D;Java虚拟机+Java核⼼类库</p></blockquote><h1 id="2、什么是字节码？采用字节码的最大好处是什么？"><a href="#2、什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="2、什么是字节码？采用字节码的最大好处是什么？"></a>2、什么是字节码？采用字节码的最大好处是什么？</h1><p>字节码是JVM可以理解的代码就叫做字节码（即源程序(.java文件)通过编译产生的产物（.class文件）），它不面向任何特定的处理器，只面向JVM，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行</p><p>好处：</p><ul><li>可移植性：由于字节码是中间代码，并不针对一种特定的机器，因此Java程序无须重新编译就可以在多种操作系统的计算机上运行（不同的操作系统和硬件平台可能需要不同的JVM实现，但是它们都可以执行相同的字节码程序）。</li><li>安全性：由于字节码需要在JVM中运行，所以可以对字节码进行安全检查，以确保程序不会对系统造成威胁</li><li>性能：由于字节码是⼀种紧凑的⼆进制格式，相⽐于直接编译为机器码，可以更快地加载和传输，同时也可以 在运⾏时进⾏动态优化，提⾼程序的执⾏效率。</li><li>可读性：相⽐于直接编译为机器码，字节码具有更好的可读性，可以⽅便地进⾏反汇编和调试。</li></ul><p><img src="https://img.wcw231407.cn/202404152059393.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h1 id="3、什么是数据库事务？讲一下事务的-ACID-特性？"><a href="#3、什么是数据库事务？讲一下事务的-ACID-特性？" class="headerlink" title="3、什么是数据库事务？讲一下事务的 ACID 特性？"></a>3、什么是数据库事务？讲一下事务的 ACID 特性？</h1><p>事务是若干个SQL语句构成的一个操作序列，这些操作表示一个完整的功能，并且需要保证功能的完整性，因此要求在该事务中要求所有的sql要么都执行，要么都不执行，是一个不可分割的整体单位。（简单来说就是由多个小任务的组成的任务）</p><p><strong>事务的ACID特性</strong></p><ul><li>原子性（Atomicity）：事务是一个不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作出错，回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态。</li><li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</li><li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱结束前，B不能向这张卡转账。</li><li>持久性（Durability）：事务一旦被提交后，事务对数据库的所有更新将被永远保存到数据库，不能回滚。</li></ul><h1 id="4、Java-和-C-、Go-语⾔的区别，各⾃的优缺点？"><a href="#4、Java-和-C-、Go-语⾔的区别，各⾃的优缺点？" class="headerlink" title="4、Java 和 C++、Go 语⾔的区别，各⾃的优缺点？"></a>4、Java 和 C++、Go 语⾔的区别，各⾃的优缺点？</h1><p><strong>Java优点：</strong></p><ul><li>平台性强(跨平台)：Java 虚拟机（JVM）可以在不同的操作系统上运⾏ Java 程序，使得开发者可以编写⼀次代 码并在多个平台上运⾏</li><li>安全性⾼：Java 有很多安全特性，例如⾃动内存管理、类的访问权限控制、异常处理等，可以有效避免⼀些 常⻅的安全漏洞；</li><li>⽣态系统完备：Java 的⽣态系统⾮常完善，有很多成熟的框架和⼯具可以帮助开发者快速构建复杂的应⽤。</li></ul><p>​    <strong>缺点：</strong></p><ul><li>由于JVM的存在，运⾏速度相对较慢</li><li>对于实时性要求较⾼的场景，Java的表现可能不如C++和Go</li></ul><p><strong>go语言优点：</strong></p><ul><li>⾼并发，天⽣⽀持协程，能够轻松编写⾼效的并发程序</li><li>简单易学，语法简洁，上⼿容易</li><li>静态类型语⾔，可以避免⼀些潜在的运⾏时错误</li><li>快速编译，可以快速构建和部署应⽤程序</li></ul><p>​    <strong>缺点：</strong></p><ul><li>缺乏丰富的类库，与 Java 和 C++ 相⽐有些不⾜</li><li>在⼀些性能要求极⾼的场景中可能不如 C++ 表现</li><li>语⾔本身还⽐较年轻，相关⽣态和⼯具还需要进⼀步完善</li></ul><p><strong>C++优点：</strong></p><ul><li>速度快，适合编写需要⾼性能的应⽤程序</li><li>应⽤⼴泛，特别是在游戏开发、操作系统和嵌⼊式系统开发⽅⾯</li><li>灵活性⾼，可以直接访问硬件和内存</li></ul><p>​    <strong>缺点：</strong></p><ul><li>学习难度较⾼，需要掌握指针、内存管理等底层知识</li><li>容易出现内存泄漏和指针错误等问题</li><li>编写代码过程中需要更多的⼿动管理，相⽐ Java 更容易出错</li></ul><h1 id="5、Java-中-final-关键字有什么用？"><a href="#5、Java-中-final-关键字有什么用？" class="headerlink" title="5、Java 中 final 关键字有什么用？"></a>5、Java 中 final 关键字有什么用？</h1><p>1.final 修饰类，表示该类不能被继承。final 类中的⽅法默认都是 final 的，不能被⼦类重写。</p><ol start="2"><li>final 修饰⽅法，表示该⽅法不能被⼦类重写。</li><li>final 修饰变量，表示该变量只能被赋值⼀次。final 修饰的变量必须在声明时或构造函数中初始化，且不能再 被修改。常⽤于定义常量。</li></ol><p>4.确保对象引⽤不可变，在对象引⽤声明前加上 final 关键字，可以确保该引⽤指向的对象不能被改变，但是该对象的内容可以被改变。例如，final MyClass obj &#x3D; new MyClass(); 将 obj 声明为⼀个不可变引⽤，指向⼀个可变的 MyClass 对象。</p><blockquote><p>何为”不可变的对象引用”呢？</p><p>​    final只保证引用类型变量所引用的地址不会改变，即一直引用同一个对象，但是这个对象的内容(对象的非final成员变量的值可以改变)完全可以发生改变（比如final int[] intArray;，intArray不允许再引用其他对象，但是intArray内的int值却可以被修改）</p></blockquote><blockquote><p>使⽤ final 修饰的变量在编译时就已经确定了其值，因此在运⾏时访问时⽐⾮ final 变量更快。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud实用篇（五）——RabbitMQ</title>
      <link href="/2024/04/15/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94RabbitMQ/"/>
      <url>/2024/04/15/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="服务异步通讯"><a href="#服务异步通讯" class="headerlink" title="服务异步通讯"></a><strong>服务异步通讯</strong></h1><h2 id="MQ（消息队列）"><a href="#MQ（消息队列）" class="headerlink" title="MQ（消息队列）"></a><strong>MQ（消息队列）</strong></h2><h3 id="同步通讯和异步通讯"><a href="#同步通讯和异步通讯" class="headerlink" title="同步通讯和异步通讯"></a><strong>同步通讯和异步通讯</strong></h3><p>学习MQ之前，先学习同步通讯和异步通讯</p><p><strong>同步通讯</strong></p><p>同步通讯指的是通讯双方需要在时间上保持一致，也就是一个操作必须等待另一个操作完成后才能执行下一个操作。</p><p>比如一个请求需要等待服务器返回结果之后才能继续处理下一个请求。</p><p>同步通讯方式的特点：</p><ol><li>简单明了</li><li>适用于处理量不大、并发量不高的场景</li></ol><p>缺点：</p><ol><li>阻塞等待：在同步通讯过程中，请求方需要等待响应方返回数据，这个等待过程可能会阻塞请求方的线程，从而导致程序无法继续执行其他任务。</li><li>慢速处理：由于同步通讯需要等待响应方返回数据后再进行下一步处理，所以它的处理速度相对慢，特别是在高并发量和大数据量的情况下。</li><li>处理逻辑复杂：同步通讯需要明确的时间规划和处理顺序，这往往需要编写更复杂的代码逻辑，增加了程序的开发难度和维护成本。</li><li>可靠性低：由于同步通讯需要双方在时间上保持一致，所以如果其中一个方出现了问题，可能会导致整个通讯过程失败，进而影响到整个系统的正常运行。</li></ol><p>同步调用存在问题：</p><ol><li>耦合度高：每次加入新的需求，都要修改原来的代码</li><li>性能下降：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。</li><li>资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li><li>级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障</li></ol><p><strong>异步通讯</strong></p><p>异步通讯则是指通讯双方不需要时间上保持一致，也就是一个操作可以在另一个操作执行的过程中继续执行。</p><p>异步通讯方式特点：</p><ol><li>高效性</li><li>灵活性</li><li>适用于处理大数据量、高并发量的场景</li></ol><p>缺点：</p><ol><li>多线程开销：由于异步通讯需要使用多线程来处理并发请求，所以会占用更多的系统资源和内存空间，进而增加系统开销和负担。</li><li>处理逻辑复杂：由于异步通讯需要使用回调函数等机制来处理回应消息，所以编写程序时需要设计更复杂的逻辑和代码结构。</li><li>可读性低：异步通讯中的回调函数容易形成层层嵌套的调用关系，这会影响程序的可读性和可维护性。</li><li>调试难度大：由于异步通讯中的执行顺序不是固定的，同时又涉及到多线程、事件驱动等复杂的技术，所以对程序进行调试比同步通讯更为困难。</li></ol><p>异步通讯的典型例子包括消息队列、事件驱动等。</p><p>在团队合作中的异步通信发生在没有实时对话或交互的情况下，比如通过邮件、留言等方式进行沟通；而同步通信则是在实时对话或交互的情况下进行，比如在线会议、视频通话等。需要根据具体的情况选择使用异步或同步通讯方式，以达到最佳的工作效果。</p><p><img src="http://img.wcw231407.cn/202404151415161.png" alt="image-20240415141551972"></p><blockquote><p>统一发送，但是服务执行的时间并不要同时完成</p><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li><p>消息发送者：投递消息的人，就是原来的调用方</p></li><li><p>消息代理：管理、暂存、转发消息，你可以把它理解成微信服务器</p></li><li><p>消息接收者：接收和处理消息的人，就是原来的服务提供方</p></li></ul></blockquote><p><img src="https://img.wcw231407.cn/202404151417659.png" alt="image-20240415141728572">异步调用优势</p><ol><li>服务解耦</li><li>性能提升，吞吐量提高</li><li>服务没有强依赖，不担心级联失败问题</li><li>流量削峰</li></ol><p><img src="https://img.wcw231407.cn/202404151418077.png" alt="image-20240415141817012"></p><p>四种MQ：主要是使用RabbiMQ 、RocketMQ、Kafka</p><p><img src="http://img.wcw231407.cn/202404151418966.png" alt="image-20240415141842883"></p><p><img src="http://img.wcw231407.cn/202404151418433.png" alt="image-20240415141855359"></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a><strong>RabbitMQ</strong></h2><h3 id="介绍与安装"><a href="#介绍与安装" class="headerlink" title="介绍与安装"></a><strong>介绍与安装</strong></h3><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：</p><p><a href="https://www.rabbitmq.com/">Messaging that just works — RabbitMQ</a> 接下来，我们就学习它的基本概念和基础用法。</p><p>将提供的mq.tar文件拉近服务器</p><p>执行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mq.tar</span><br></pre></td></tr></table></figure><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hmall \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用docker load命令加载：</p><p><img src="https://img.wcw231407.cn/202404151420015.png" alt="image-20240415142034937"></p><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问 <a href="http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。登录后即可看到管理控制台总览页面：">http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。登录后即可看到管理控制台总览页面：</a></p><p><img src="https://img.wcw231407.cn/202404151421893.png" alt="image-20240415142105800">安装完成后，我们访问</p><p><a href="http://192.168.150.101:15672/">http://192.168.150.101:15672</a>即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。 登录后即可看到管理控制台总览页面：</p><p>RabbitMQ对应的架构如图：</p><p><img src="https://img.wcw231407.cn/202404151421611.png" alt="image-20240415142159538"></p><p>其中包含几个概念：</p><ul><li>virtual-host：虚拟主机，起到数据管理的作用</li><li>publisher：消息发送者</li><li>consumer：消息的消费者</li><li>queue：队列，存储消息</li><li>exchange：交换机，负责路由消息</li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a><strong>快速入门</strong></h3><p>需求：在RabbitMQ的控制台完成下列操作：</p><ul><li>新建队列hello.queue1和hello.queue2</li><li>向默认的amp.fanout交换机发送一条消息</li><li>查看是否达到hello.queue1和hello.queue2</li></ul><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a><strong>交换机</strong></h4><p>我们打开Exchanges选项卡，可以看到已经存在很多交换机：我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：</p><p><img src="https://img.wcw231407.cn/202404151423272.png" alt="image-20240415142337166"></p><p>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><p><img src="https://img.wcw231407.cn/202404151425774.png" alt="image-20240415142508692"></p><p><img src="http://img.wcw231407.cn/202404151425683.png" alt="image-20240415142537622"></p><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a><strong>队列</strong></h4><p>我们打开Queues选项卡，新建一个队列：</p><p>命名为hello.queue1：</p><p>再以相同的方式，创建一个队列，密码为hello.queue2，最终队列列表如下：</p><p>此时，我们再次向amq.fanout交换机发送一条消息。会发现消息依然没有到达队列！！</p><p>怎么回事呢？</p><p>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><p><img src="https://img.wcw231407.cn/202404151427208.png" alt="image-20240415142737157"></p><p><img src="https://img.wcw231407.cn/202404151427362.png" alt="image-20240415142753261"></p><p><img src="https://img.wcw231407.cn/202404151428067.png" alt="image-20240415142810006"></p><h4 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a><strong>绑定关系</strong></h4><p>点击Exchanges选项卡，点击amq.fanout交换机，进入交换机详情页，然后点击Bindings菜单，在表单中填写要绑定的队列名称：</p><p>相同的方式，将hello.queue2也绑定到改交换机。</p><p>最终，绑定结果如下：</p><p><img src="https://img.wcw231407.cn/202404151428903.png" alt="image-20240415142854852"></p><p><img src="http://img.wcw231407.cn/202404151429315.png" alt="image-20240415142910259"></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a><strong>发送消息</strong></h4><p>再次回到exchange页面，找到刚刚绑定的amq.fanout，点击进入详情页，再次发送一条消息：</p><p>回到Queues页面，可以发现hello.queue中已经有一条消息了：</p><p>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：</p><p>可以看到消息到达队列了：</p><p>这个时候如果有消费者监听了MQ的hello.queue1或hello.queue2队列，自然就能接收到消息了。</p><p><img src="http://img.wcw231407.cn/202404151429636.png" alt="image-20240415142942583"></p><p><img src="https://img.wcw231407.cn/202404151429569.png" alt="image-20240415142957475"></p><p><img src="https://img.wcw231407.cn/202404151430866.png" alt="image-20240415143016803"></p><p><img src="https://img.wcw231407.cn/202404151430778.png" alt="image-20240415143034707"></p><h3 id="数据隔离"><a href="#数据隔离" class="headerlink" title="数据隔离"></a><strong>数据隔离</strong></h3><p>需求：在RabbitMQ的控制台完成下列操作：</p><ul><li>新建一个用户hamall</li><li>为hmall用户创建一个virtual host</li><li>测试不同virtual host之间的数据隔离现象</li></ul><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a><strong>用户管理</strong></h4><p>点击Admin选项卡，首先会看到RabbitMQ控制台的用户管理界面：这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的itheima这个用户。仔细观察用户表格中的字段，如下：</p><p><img src="https://img.wcw231407.cn/202404151431372.png" alt="image-20240415143156267"></p><ul><li>Name</li></ul><p>：itheima，也就是用户名</p><ul><li>Tags</li></ul><p>：administrator，说明itheima用户是超级管理员，拥有所有权限</p><ul><li>Can access virtual host</li></ul><p>： &#x2F;，可以访问的virtual host，这里的&#x2F;是默认的virtual host</p><p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用virtual host的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的</li></ul><p>virtual host，将每个项目的数据隔离。</p><p>比如，我们给黑马商城创建一个新的用户，命名为hmall：你会发现此时hmall用户没有任何virtual host的访问权限：别急，接下来我们就来授权。</p><p><img src="https://img.wcw231407.cn/202404151432456.png" alt="image-20240415143237400"></p><p><img src="https://img.wcw231407.cn/202404151435418.png" alt="image-20240415143522340"></p><h4 id="virtual-host"><a href="#virtual-host" class="headerlink" title="virtual host"></a><strong>virtual host</strong></h4><p>我们先退出登录：切换到刚刚创建的hmall用户登录，然后点击Virtual Hosts菜单，进入virtual host管理页：可以看到目前只有一个默认的virtual host，名字为 &#x2F;。 我们可以给黑马商城项目创建一个单独的virtual host，而不是使用默认的&#x2F;。创建完成后如图：由于我们是登录hmall账户后创建的virtual host，因此回到users菜单，你会发现当前用户已经具备了对&#x2F;hmall这个virtual host的访问权限了：</p><p><img src="https://img.wcw231407.cn/202404151436656.png" alt="image-20240415143603599"></p><p><img src="https://img.wcw231407.cn/202404151436723.png" alt="image-20240415143623670"></p><p><img src="https://img.wcw231407.cn/202404151436711.png" alt="image-20240415143637627"></p><p><img src="https://img.wcw231407.cn/202404151436713.png" alt="image-20240415143650641"></p><p><img src="https://img.wcw231407.cn/202404151437464.png" alt="image-20240415143705398"></p><p>此时，点击页面右上角的virtual host下拉菜单，切换virtual host为 &#x2F;hmall：然后再次查看queues选项卡，会发现之前的队列已经看不到了：这就是基于virtual host的隔离效果。</p><p><img src="https://img.wcw231407.cn/202404151438869.png" alt="image-20240415143850767"></p><p><img src="https://img.wcw231407.cn/202404151439878.png" alt="image-20240415143907825"></p><h3 id="java客户端-快速入门"><a href="#java客户端-快速入门" class="headerlink" title="java客户端-快速入门"></a><strong>java客户端-快速入门</strong></h3><p>AMQP(Advanced Message Queuing Protocol，用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求)</p><p>Spring AMQP（是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring-amqp）是基础抽象，spring-rabbit是底层的默认实现。</p><p>需求如下：</p><ul><li>利用控制台创建队列simple.queue</li><li>在publisher服务中，利用SpringAMQP直接向simple.queue分手发送消息</li><li>在consumer服务中，利用SpringAMQP编写消费者，监听simple.queue队列</li></ul><p>1.创建队列simple.queue</p><p><img src="/https/:img.wcw231407.cn/202404151450125.png" alt="image-20240415145026046"></p><p>2.在父工程中中引入spring-amqp依赖，这样publish和consumer服务都可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>3.在每一个微服务中引入 MQ服务端信息，这样微服务才能连接到RabbitMQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: 112.124.30.198</span><br><span class="line">    port: 5672</span><br><span class="line">    virtual-host: /wcw</span><br><span class="line">    username: hmall</span><br><span class="line">    password: 123</span><br></pre></td></tr></table></figure><p>4.SpringAMQP提供了RabbitTemplate工具类，方便我们发送代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowored</span><br><span class="line">private RabbitTemplate rabbitTemplate;</span><br><span class="line">@Test</span><br><span class="line">public void testSimpleQueue()&#123;</span><br><span class="line">    //队列名称</span><br><span class="line">    String quwueName = &quot;simplate.queue&quot;;</span><br><span class="line">    String message = &quot;hello,spring amqp&quot;;</span><br><span class="line">    rabbitTemplate.converAndSend(queueName,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.接收消息</p><p>SpringAMQP提供声明式的消息监听，我们只需要通过注注解在方法上声明要监听的队列名称，将来SpringAMQP就会把消息传递给当前的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Self4j</span><br><span class="line">@Component</span><br><span class="line">public class SpringRabbitListener&#123;</span><br><span class="line">    @RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">    public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123;</span><br><span class="line">        log.info(&quot;spring 消费者接收消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">        if(true)&#123;</span><br><span class="line">            throw new MessageConversionException(&quot;故意的&quot;);        </span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;消息处理完成&quot;);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.wcw231407.cn/202404151452806.png" alt="image-20240415145208689"></p><blockquote><p>SpringAMQP如何收发消息？</p><p>1.引入spring-boot-starter-amqp依赖</p><p>2.配置rabbitmq服务端消息</p><p>3.利用RabbitTemplate发送消息</p><p>4.利用@RabbitListener注解声明要监听的队列，监听消息</p></blockquote><h3 id="Work模型"><a href="#Work模型" class="headerlink" title="Work模型"></a><strong>Work模型</strong></h3><blockquote><p>模拟workQueue，实现一个队列绑定多个消费者</p><p>​    1.在RabbitMQ的控制台创建一个队列，名为work.queue</p><p>​    2.在publishe服务中定义测试方法，在1秒内产生50条消息，发送到work.queue</p><p>​    3.在consumer服务中定义两个消息监听者，都监听work.queue队列</p><p>​    4.消费者1每秒处理50条消息，消费者2每秒处理5条消息</p></blockquote><p>1.在RabbitMQ的控制台创建一个队列，名为work.queue</p><p><img src="https://img.wcw231407.cn/202404151453197.png" alt="image-20240415145352131"></p><p>2.在publisher服务中定义测试方法，在1秒内产生50条消息，发送到work.queue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void tesWorkQueue() throws InterruptedException&#123;</span><br><span class="line">    String queueName = &quot;work.queue&quot;;</span><br><span class="line">    for(int i = 0; i &lt; 50; i++ )&#123;</span><br><span class="line">        String msg = &quot;hello,work,message_&quot;+i;</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName,msg);</span><br><span class="line">        Thread.sleep(20);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在consumer服务中定义两个消息监听者，都监听work.queue队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class MqListener &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;simple.queue&quot;)</span><br><span class="line">    public  void listenSimpleQueue(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;spring 消费者接收消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @RabbitListener(queues = &quot;work.queue&quot;)</span><br><span class="line">    public  void listenWorkQueue1(String msg)&#123;</span><br><span class="line">        System.out.println(&quot;消费者1 收到WorkQueue消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @RabbitListener(queues = &quot;work.queue&quot;)</span><br><span class="line">    public  void listenWorkQueue2(String msg)&#123;</span><br><span class="line">        System.err.println(&quot;消费者2 收到WorkQueue消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，RabbitMQ的会将消息依次轮询投递给绑定在队列上的每一个消费者。但这并没有考虑到消费者是否已经处理完消息，可能出现消息堆积。</p><p>因此我们需要修改application.yml,设置preFetch值为1，确保同一时刻最多投递给消费者1条消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    rabbitmq:</span><br><span class="line">        listener:</span><br><span class="line">          simple:</span><br><span class="line">            prefetch: 1#每次只能获取一条消息，处理完成才能获取下一个消息</span><br></pre></td></tr></table></figure><p><img src="https://img.wcw231407.cn/202404151454806.png" alt="image-20240415145457739"></p><blockquote><p>work模型的使用：</p><ul><li>多个消费者绑定到一个队列，可以加快消息处理速度</li><li>同一个消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量，处理完一条处理下一条，实现能者多劳</li></ul></blockquote><h3 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a><strong>交换机</strong></h3><p>真正生产环境都会经过exchange来发送消息，而不是直接发送给队列，交换机的类型有以下三钟：</p><ul><li>Fanout：广播</li><li>Direct：定向</li><li>Topic：话题</li></ul><h4 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a><strong>Fanout交换机</strong></h4><p>Fanout Exchange 会将接收到每一个跟其绑定的queue，所以也叫广播模式</p><p><img src="https://img.wcw231407.cn/202404151456652.png" alt="image-20240415145605575"></p><blockquote><p>实现思路：</p><p>​在RabbitMQ控制台中，声明队列fanout.queue1和fanout.queue2</p><p>​在RabbitMQ控制台中，声明交换机hmall。fanout,将两个队列与其绑定</p><p>​在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</p><p>​在publisher中编写测试方法，向hmall.fanout发送消息</p></blockquote><p>1.在RabbitMQ控制台中，声明队列fanout.queue1和fanout.queue2</p><p><img src="https://img.wcw231407.cn/202404151456532.png" alt="image-20240415145656482"></p><p>2.在RabbitMQ控制台中，声明交换机hmall.fanout,将两个队列与其绑定</p><p><img src="https://img.wcw231407.cn/202404151457097.png" alt="image-20240415145719047"></p><p><img src="https://img.wcw231407.cn/202404151457313.png" alt="image-20240415145729249"></p><p>3.在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span><br><span class="line">public  void listenFanoutQueue1(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者1 收到fanoutQueue1消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    Thread.sleep(20);</span><br><span class="line">&#125;</span><br><span class="line">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span><br><span class="line">public  void listenFanoutQueue2(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者2 收到fanoutQueue2消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在publisher中编写测试方法，向hmall.fanout发送消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testSendFanout()&#123;</span><br><span class="line">    String exChangeName = &quot;hmall.fanout&quot;;</span><br><span class="line">    String msg = &quot;hello,everyone&quot;;</span><br><span class="line">    rabbitTemplate.convertAndSend(exChangeName,null,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.wcw231407.cn/202404151458335.png" alt="image-20240415145857235"></p><blockquote><p>交换机的作用是什么？</p><ul><li>接接收publisher发送的消息</li><li>将消息按规则路由到与之绑定的队列</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul></blockquote><h4 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a><strong>Direct交换机</strong></h4><p>Direct Exchange会将接收到消息根据规则路由到指定的Queue，因此成为定向路由</p><ul><li>每个Queue都与Exchange设置一个BindKey</li><li>发布者发送消息时，指定消息的RoutingKry</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li></ul><p><img src="https://img.wcw231407.cn/202404151459601.png" alt="image-20240415145958511"></p><blockquote><p>需求：</p><ul><li><p>在RabbitMQ控制台中，声明对列direct.queue1和direct.queue2</p></li><li><p>在RabbitMQ控制台中，声明交换机hmall.dirext,将两个队列与其绑定</p></li><li><p>在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p></li><li><p>在publicsher中编写测试方法，利用不同的RoutingKey向hmall.direct发送消息</p></li></ul></blockquote><p>1.在RabbitMQ控制台中，声明对列direct.queue1和direct.queue2</p><p><strong><img src="https://img.wcw231407.cn/202404151500969.png" alt="image-20240415150056867"></strong></p><p>2.在RabbitMQ控制台中，声明交换机hmall,dirext,将两个队列与其绑定</p><p><img src="https://img.wcw231407.cn/202404151501828.png" alt="image-20240415150117746"></p><p>3.在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;direct.queue1&quot;)</span><br><span class="line">public  void listenDirectQueue1(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者1 收到fanoutQueue1消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    Thread.sleep(20);</span><br><span class="line">&#125;</span><br><span class="line">@RabbitListener(queues = &quot;direct.queue2&quot;)</span><br><span class="line">public  void listenDirectQueue2(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者2 收到fanoutQueue2消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在publicsher中编写测试方法，利用不同的RoutingKey向hmall.direct发送消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testSendDirect1()&#123;</span><br><span class="line">    String exChangeName = &quot;hmall.direct&quot;;</span><br><span class="line">    String msg = &quot;hello,everyone&quot;;</span><br><span class="line">    rabbitTemplate.convertAndSend(exChangeName,&quot;red&quot;,msg);</span><br><span class="line">&#125;</span><br><span class="line">@Test</span><br><span class="line">void testSendDirect2()&#123;</span><br><span class="line">    String exChangeName = &quot;hmall.direct&quot;;</span><br><span class="line">    String msg = &quot;hello,everyone&quot;;</span><br><span class="line">    rabbitTemplate.convertAndSend(exChangeName,&quot;blue&quot;,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先测试键为red（路由绑定队列共有的键）的测试方法，测试结果如图所示：</p><p><img src="https://img.wcw231407.cn/202404151502815.png" alt="image-20240415150231742"></p><p>在测试键为blue的键（这是directQueue1独有的键），因此如下只有收到directQueue1的消息</p><p><img src="https://img.wcw231407.cn/202404151503221.png" alt="image-20240415150310111"></p><h4 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a><strong>Topic交换机</strong></h4><p>TopicExchange与DirectExchange类似，区别在于routingKey可以是多个单词的列表，并以.分割</p><ul><li>#：代指0个或多个单词</li><li>*：代指一个单词</li></ul><p><img src="https://img.wcw231407.cn/202404151503570.png" alt="image-20240415150346468"></p><blockquote><p>需求如下：</p><p>1.在RabbitMQ控制台中，声明队列topic.queue1和topic.queue2</p><p>2.在RabbitMQ控制台中，声明交换机hmall.topic,将两个队列与其绑定</p><p>3.在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p><p>4.publisher中编写测试方法，利用不同的RoutingKey向hmall.topic发送消息</p></blockquote><p>1.在RabbitMQ控制台中，声明队列topic.queue1和topic.queue2</p><p><img src="https://img.wcw231407.cn/202404151504365.png" alt="image-20240415150408303"></p><p>2.在RabbitMQ控制台中，声明交换机hmall.topic,将两个队列与其绑定</p><p><img src="https://img.wcw231407.cn/202404151504160.png" alt="image-20240415150444087"></p><p>3.在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues = &quot;topic.queue1&quot;)</span><br><span class="line">public  void listenTopicQueue1(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者1 收到topicQueue1消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@RabbitListener(queues = &quot;topic.queue2&quot;)</span><br><span class="line">public  void listenTopicQueue2(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者2 收到topicQueue2消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.publisher中编写测试方法，利用不同的RoutingKey向hmall.topic发送消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testSendTopic1()&#123;</span><br><span class="line">    String exChangeName = &quot;hmall.topic&quot;;</span><br><span class="line">    String msg = &quot;我来通知你了！！！&quot;;</span><br><span class="line">    rabbitTemplate.convertAndSend(exChangeName,&quot;japan.news&quot;,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.wcw231407.cn/202404151505386.png" alt="image-20240415150534327"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testSendTopic2()&#123;</span><br><span class="line">    String exChangeName = &quot;hmall.topic&quot;;</span><br><span class="line">    String msg = &quot;今天天气很不错，我的心情特别好！！！&quot;;</span><br><span class="line">    rabbitTemplate.convertAndSend(exChangeName,&quot;chain.weather&quot;,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.wcw231407.cn/202404151506244.png" alt="image-20240415150626183"></p><blockquote><p>描述下Direct交换机和Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey可以是多个单词，以.分割</li><li>Topic交换机与队列绑定时的bingdingKey可以指定通配符</li><li>#：代表0个或多个词</li><li>*：代表1个词</li></ul></blockquote><h3 id="基于注解-RabbitListener声明队列和交换机"><a href="#基于注解-RabbitListener声明队列和交换机" class="headerlink" title="基于注解@RabbitListener声明队列和交换机"></a><strong>基于注解@RabbitListener声明队列和交换机</strong></h3><p>记得停止项目运行在删除上面得交换机和队列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//@RabbitListener(queues = &quot;direct.queue1&quot;)</span><br><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(name = &quot;direct.queue1&quot;,durable = &quot;true&quot;),</span><br><span class="line">        exchange = @Exchange(name = &quot;hmall.direct&quot;,type = ExchangeTypes.DIRECT),</span><br><span class="line">        key = &#123;&quot;red&quot;,&quot;blue&quot;&#125;</span><br><span class="line">))</span><br><span class="line">public  void listenDirectQueue1(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者1 收到directQueue1消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    Thread.sleep(20);</span><br><span class="line">&#125;</span><br><span class="line">//@RabbitListener(queues = &quot;direct.queue2&quot;)</span><br><span class="line">@RabbitListener(bindings = @QueueBinding(</span><br><span class="line">        value = @Queue(name = &quot;direct.queue2&quot;,durable = &quot;true&quot;),</span><br><span class="line">        exchange = @Exchange(name = &quot;hmall.direct&quot;,type = ExchangeTypes.DIRECT),</span><br><span class="line">        key = &#123;&quot;red&quot;,&quot;yellow&quot;&#125;</span><br><span class="line">))</span><br><span class="line">public  void listenDirectQueue2(String msg) throws InterruptedException&#123;</span><br><span class="line">    System.out.println(&quot;消费者2 收到directQueue2消息：【&quot;+msg+&quot;】&quot;);</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.wcw231407.cn/202404151508323.png" alt="image-20240415150838262"></p><p><img src="https://img.wcw231407.cn/202404151508232.png" alt="image-20240415150854136"></p><blockquote><p>声明队列、交换机、绑定关系得Bean是什么？</p><ul><li>Queue</li><li>FanoutExchange、DirectExchange、TopicExchange</li><li>Binding</li></ul><p>基于@RabbitListener注解声明队列和交换机有哪些常见注解？</p><ul><li>@Queue</li><li>Exchange</li><li>@QueueBinding</li></ul></blockquote><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a><strong>消息转换器</strong></h3><p>需求：测试利用SpringAMQP发送对象型的消息</p><ol><li>声明一个队列，名为object.queue</li><li>编写单元测试，向一个队列直接发送一个消息，消息类型为Map</li><li>在控制台查看消息，直接你能发现的问题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//准备消息</span><br><span class="line">Map&lt;String,Obeject&gt; msg = new HashMap&lt;&gt;();</span><br><span class="line">msg.put(&quot;name&quot;,&quot;Jack&quot;);</span><br><span class="line">msg.put(&quot;age&quot;,21);</span><br></pre></td></tr></table></figure><p>1.声明一个队列，名为object.queue</p><p><img src="https://img.wcw231407.cn/202404151509957.png" alt="image-20240415150954892"></p><p>2.编写单元测试，向一个队列直接发送一个消息，消息类型为Map</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void  testSendObject()&#123;</span><br><span class="line">    Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;(2);</span><br><span class="line">    msg.put(&quot;name&quot;,&quot;jack&quot;);</span><br><span class="line">    msg.put(&quot;age&quot;,21);</span><br><span class="line">    rabbitTemplate.convertAndSend(&quot;object.queue&quot;,msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试代码我们发现，队列存的是一串我们不认识的字符串（字节码）</p><p><img src="https://img.wcw231407.cn/202404151510869.png" alt="image-20240415151046809"></p><p>3.引入Jackson依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Jackson--&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>4.在启动类上添加下面的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MessageConverter jacksonMessageConvertor()&#123;</span><br><span class="line">    return new Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次启动一下测试类</p><p>然后在rabittmq管理端查看队列，如图：</p><p><img src="https://img.wcw231407.cn/202404151511453.png" alt="image-20240415151155347"></p><p>5.编写一个接收消息的方法</p><p><img src="https://img.wcw231407.cn/202404151512822.png" alt="image-20240415151222747"></p><p><img src="https://img.wcw231407.cn/202404151512352.png" alt="image-20240415151229269"></p><p>第一个被原生的序列化的字节序列当消费者收到时直接报错，第二条被json序列化的数据接收正常</p><p><img src="https://img.wcw231407.cn/202404151513654.png" alt="image-20240415151308584"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT实用技巧与接入ChatGPT</title>
      <link href="/2024/04/14/ChatGPT%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%8E%A5%E5%85%A5ChatGPT/"/>
      <url>/2024/04/14/ChatGPT%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E6%8E%A5%E5%85%A5ChatGPT/</url>
      
        <content type="html"><![CDATA[<h1 id="ChatGPT交互单位：Token"><a href="#ChatGPT交互单位：Token" class="headerlink" title="ChatGPT交互单位：Token"></a><strong>ChatGPT交互单位：Token</strong></h1><p>Token：这个指的是OpenAI处理文本的<strong>基本单位</strong>，可以是单词或者字符的片段、一个标点符号或数字。</p><ul><li>1个token大约相当于四个字符或者0.75个单词。例如，“hamburger”被分成“ham”、“bur”和“ger”三个Token，而“pear”是一个Token。</li><li>一个汉字会被拆成大约Token。</li></ul><p>OpenAI的模型有一个固定长度的Token限制。</p><ul><li>例如：GPT-3的Davinci模型最多可以处理2049个Token，大约1500个单词。最新Turbo模型大约是4096个Token，大约是3000个单词。</li><li>Token限制的计数包含输入和输出的文本。也就是说，比如“输入+输出”总共不能超过3000个英文单词。</li></ul><h1 id="训练语料的截至时间"><a href="#训练语料的截至时间" class="headerlink" title="训练语料的截至时间"></a><strong>训练语料的截至时间</strong></h1><p>ChatGPT、GPT-4的数据仅有2022年1月以前的，如果你问这个时间以后的问题，它就不能提供有效信息了。</p><h1 id="AIGC、PGC、UGC"><a href="#AIGC、PGC、UGC" class="headerlink" title="AIGC、PGC、UGC"></a><strong>AIGC、PGC、UGC</strong></h1><p>AIGC即AI Generate Content,是指利用人工智能技术来生成内容，AIGC也被认为是继PGC（专业生产内容）、UGC（用户生产内容）之后的新型内容生产方式，AI绘画、AI写作等都属于AIGC的分支。</p><p>进一步理解时，AIGC有狭义和广义概念之分。</p><ul><li>狭义的AIGC与普通用户更为贴近，更关注图像、文本、音频、视频等，和Generative AI（生成式AI）Aynthetic media（合成式媒体）等概念类似。</li><li>论广义概念，还包含策略生成（如Game AI中游戏策略生成）、代码生成（GitHub Copilot）、蛋白质结构生成等。</li></ul><h1 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a><strong>Prompt</strong></h1><p><strong>Prompt（提示）工程师的理解</strong></p><p>1.何为提示工程师</p><p>提示工程师的职责是创建和完善人们向人工智能输入的文本提示，希望从中能获得最佳结果。有时候，一行精准、专业且完美的prompt，甚至可以价值千金。</p><p>有时候同一提示的不同表述，对大众来说，可能听起来很相似，但却能让AI产生完全不同的结果。而一个成功的提示工程师将找到一种方法来引导模型产生有用的输出</p><h1 id="五大原则"><a href="#五大原则" class="headerlink" title="五大原则"></a><strong>五大原则</strong></h1><p>想要让ChatGPT产出有效的回答，需要遵循以下五个原则：</p><ul><li>提问清晰：请尽可能清晰地描述你的问题</li><li>简明扼要：请尽量使用简单的语言和简洁的句子来表达你的问题</li><li>确认问题：请确认您的问题是清晰、明确和完整</li><li>单一提问：请一个一个地问，而不是把所有问题放在一个问题中</li><li>不要提供敏感信息：请不要在您的问题中提供任何个人敏感信息</li></ul><h1 id="基本三要素："><a href="#基本三要素：" class="headerlink" title="基本三要素："></a><strong>基本三要素：</strong></h1><p>提示的特定格式，一般包含3个主要元素：</p><ul><li>角色：在生成文本时，模型应该扮演什么</li><li>任务：一份清晰简洁的陈述，提示要求模型生成的内容。确保输出的相关、高质量。<ul><li>动词：编写、总结、分类、翻译、排序、查找、分析、评估、改进、开发、优化等</li><li>名词（输出载体）：句子、段落（或摘要）、文章、邮件、表格、代码&#x2F;程序、求职信、论文、案例研究、合同、指南、剧本、歌词&#x2F;诗歌、商业&#x2F;运营&#x2F;财务&#x2F;营销计划等</li></ul></li><li>指示：在生成文本时，模型应该遵循什么。越直接，信息越有效。<ul><li>形容词：300字xxx，20个xx的，正式或非正式的、通俗易懂的、严肃的、幽默的、有说服力的、鼓舞人心的、讽刺的、强烈的、深思熟虑的…</li><li>前导信息&#x2F;上下文：提供来自xx的数据或研究报告、客户数据、目前已有的代码、我已完成的工作内容等</li></ul></li></ul><h1 id="Open进行程序开发（这里需要魔法，只需打开魔法就行，代码里stater我已做处理）"><a href="#Open进行程序开发（这里需要魔法，只需打开魔法就行，代码里stater我已做处理）" class="headerlink" title="Open进行程序开发（这里需要魔法，只需打开魔法就行，代码里stater我已做处理）"></a><strong>Open进行程序开发（这里需要魔法，只需打开魔法就行，代码里stater我已做处理）</strong></h1><p>1.首先拉去下面的代码到自己本地</p><p>git仓库地址：<a href="https://github.com/wcw-001/chatgpt-3-5-spring-starter">https://github.com/wcw-001/chatgpt-3-5-spring-starter</a></p><p>目录结构如下：<img src="http://img.wcw231407.cn/202404141509425.png" alt="image-20240414150711007"></p><p><img src="https://img.wcw231407.cn/202404141507655.png" alt="image-20240414150725492"></p><p>3.将此stater打包到maven仓库中</p><p><img src="https://img.wcw231407.cn/202404141509704.png" alt="image-20240414150925564"></p><p><strong>在这里我拿我自己做的数据分析平台为例引入chatgpt（简化）</strong></p><p>1.在pom文件下引入以下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.mrli&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;chatgpt-3-5-springboot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.在配置文件下配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chatgpt:</span><br><span class="line">  token: 填自己chatgpt密钥</span><br><span class="line">  timeout: 1000</span><br><span class="line">  username:</span><br><span class="line">  password:</span><br><span class="line">  ip: 127.0.0.1</span><br><span class="line">  port: 7890（有自己使用的魔法工具决定）</span><br></pre></td></tr></table></figure><p>3.在dto层创建一个数据传输类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class RequestDto &#123;</span><br><span class="line">    @NotBlank(message=&quot;消息不能为空&quot;)</span><br><span class="line">    private String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.创建chatGPT包，在包下创建如下类:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AiManager &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private YuCongMingClient client;</span><br><span class="line">    public String doChat(Long biModelId,String message)&#123;</span><br><span class="line">        DevChatRequest devChatRequest = new DevChatRequest();</span><br><span class="line">        devChatRequest.setModelId(biModelId);</span><br><span class="line">        devChatRequest.setMessage(message);</span><br><span class="line">        BaseResponse&lt;DevChatResponse&gt; response = client.doChat(devChatRequest);</span><br><span class="line">        if(response == null)&#123;</span><br><span class="line">            throw new BusinessException(ErrorCode.SYSTEM_ERROR,&quot;AI 响应错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return response.getData().getContent();</span><br><span class="line">    &#125;</span><br><span class="line">    private  final ChatGptConfig config;</span><br><span class="line"></span><br><span class="line">    public AiManager(ChatGptConfig config) &#123;</span><br><span class="line">        this.config=config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String doChatGPT(RequestDto requestDto)&#123;</span><br><span class="line">        OpenAiService service = new OpenAiService(config);</span><br><span class="line">        String message = requestDto.getMessage();</span><br><span class="line">        List&lt;ChatMessage&gt; messages = new ArrayList&lt;&gt;();</span><br><span class="line">        ChatMessage e = new ChatMessage();</span><br><span class="line">        e.setRole(&quot;user&quot;);</span><br><span class="line">        e.setContent(message);</span><br><span class="line">        messages.add(e);</span><br><span class="line">        ChatCompletionRequest completionRequest = ChatCompletionRequest.builder()</span><br><span class="line">                .model(&quot;gpt-3.5-turbo&quot;)</span><br><span class="line">                .messages(messages)</span><br><span class="line">                .build();</span><br><span class="line">        ChatCompletionResult completion = service.createChatCompletion(completionRequest);</span><br><span class="line">        List&lt;ChatCompletionChoice&gt; choices = completion.getChoices();</span><br><span class="line">        StringBuilder content = new StringBuilder();</span><br><span class="line">        for (ChatCompletionChoice choice : choices)&#123;</span><br><span class="line">            content.append(choice.getMessage().getContent());</span><br><span class="line">        &#125;</span><br><span class="line">        return content.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.只需要在controller，引入相关的数据，在调用我们上面写的类里调用chatgpt方法就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private AiManager aiManager;</span><br><span class="line">@PostMapping(&quot;/genHh&quot;)</span><br><span class="line">public String genChartByAi(@RequestBody RequestDto requestDto) &#123;</span><br><span class="line">    String result = aiManager.doChatGPT(requestDto);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们测试一下接口（可以使用工具ApiPost工具，我这里使用的是接口文档）：</p><p><img src="https://img.wcw231407.cn/202404141512215.png" alt="image-20240414151218086"></p><blockquote><p><strong>总结（在这里的总结与我个人最近做的数据分析平台相关）：</strong></p><p>1、A提词技巧1：持续输入，持续优化</p><p>第一次问：我给你三行数据，请帮我分析网站的增长趋势，数据如下：第一行：日期：1号，用户数：10人第二行：日期：2号，用户数：20人第三行：日期：3号，用户数：30人</p><p>AI答：根据给出的数据，我们可以看出这个网站的用户数在三天内呈现快速增长的趋势。具体来说，该网站用户数从第一天的10人增长到第二天的20人，增勖加了10人，增长率100%；相比之下，第三天用户数从第二天的20人增长到第三天的30人，增加了同样的10人，增长率降至50%。如果这种增长趋势特续下去，我们可以预期该网站在未来几天内还会继续吸引更多用户。当然，若要得出更加准确的结论，需要更多数据的支持。</p><p>2、AI提词技巧2：数据压缩（内容压缩，比如把很长的内容提取关键词，也可以让AI来故）</p><p>我给你三行数据，请帮我分析网站的增长趋势，数据如下：表头：日期，用户数1号，102号，203号，30</p><p>AI回答：根据给出的数据，我们可以计算出每日用户增长量：</p><ul><li><p>第一天增长了10个新用户；</p></li><li><p>第二天增长了20-10&#x3D;10个新用户；</p></li><li><p>第三天增长了30-20&#x3D;10个新用户。</p></li></ul><p>可以看出，每天的用户增长量都相等，呈现一个线性增长趋势。如果这个网站在未来的时间里能够保持现在的增长速度和策略不变，预计每过一天会增勖加10个用户。但需要注意的是，这个预测是基于目前的数据情况，实际情况会受到许多因素的响，不完全准确预测未来用户增长。</p><p>使用AI来压缩：问：我给你三行数据，请帮我用最少的字数压缩这设数据第一行：日期：1号，用户数：10人第二行：日期：2号，用户数：20人第三行：日期：3号，用户数：30人答：日期1-3号，用户数分别为10&#x2F;20&#x2F;30人。</p><p>3、AI 提词技巧3：在系统（模型）层面做妤预设效果一股来说，会比直接拼接在用户消息里效果更好一些。</p><p>4、AI提词技巧4：除了系统预设外，额外关联一问一答两条消息，相当于给A!一个提示。</p><p><strong>1.1.1 AI提问技巧</strong></p><p>如果得要让 AI 更好地理解我们的输入，给我们预期的、精确格式的输出，我们就需要严格控制咱们的提问词。</p><ol><li>使用系统预设</li></ol><p>先对chatgpt指定角色</p><ol start="2"><li>控制输入格式（便于A!精确地理解我们的需求）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容： </span><br><span class="line">分析需求： </span><br><span class="line">&#123;数据分析的需求或者目标&#125; </span><br><span class="line">原始数据： </span><br><span class="line">&#123;csv格式的原始数据，用，作为分隔符&#125; </span><br><span class="line">请根据以上内容，帮我生成数据分析结论和可视化图表代码</span><br></pre></td></tr></table></figure><p>用户提问：</p><p> <img src="http://img.wcw231407.cn/202404141514430.png"></p><p>​3.控制输出格式（便于AI返回的内容能够更加方便地为我们所用）Prompt预设：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">你是一个数据分析师和前端开发专家，接下来我会按照以下固定格式给你提供内容：</span><br><span class="line">分析需求：</span><br><span class="line">&#123;数据分析的需求或者目标&#125;</span><br><span class="line">原始数据：</span><br><span class="line">&#123;csv格式的原始数据，用,作为分隔符&#125;</span><br><span class="line">请根据这两部分内容，按照以下指定格式生成内容（此外不要输出任何多余的开头、结尾、注释）</span><br><span class="line">【【【【【</span><br><span class="line">&#123;前端 Echarts V5 的 option 配置对象的json格式代码，合理地将数据进行可视化，不要生成任何多余的内容，比如注释&#125;</span><br><span class="line">【【【【【</span><br><span class="line">&#123;明确的数据分析结论、越详细越好，不要生成多余的注释&#125;</span><br></pre></td></tr></table></figure><p>用户输入：</p><p>生成的内容：</p><p>将上面的代码复制到Echarts执行：</p><p><img src="https://img.wcw231407.cn/202404141515577.png" alt="image-20240414151547434"></p><p><img src="https://img.wcw231407.cn/202404141516424.png" alt="image-20240414151606252"></p><p>​4.指定一个示例问答，one-shot或者few-shot</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud实用篇（四）——注册中心</title>
      <link href="/2024/04/04/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Nacos/"/>
      <url>/2024/04/04/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Nacos/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a><strong>Nacos</strong></h1><p>nacos官方网站：<a href="https://nacos.io/">https://nacos.io/</a></p><p>nacos是阿里巴巴的产品，现在是springcloud的一个组件，相比于eureka的功能更加丰富，在国内备受欢迎</p><h2 id="nacos的安装"><a href="#nacos的安装" class="headerlink" title="nacos的安装"></a><strong>nacos的安装</strong></h2><p>下载地址：<a href="https://github.com/alibaba/nacos/releases/">https://github.com/alibaba/nacos/releases/</a></p><p><img src="http://img.wcw231407.cn/202404041052874.png" alt="image-20240404105216248"></p><p><strong>启动方式：</strong></p><p>1.双击如图所示：</p><p><img src="http://img.wcw231407.cn/202404041053422.png" alt="image-20240404105314281"></p><p>2.cmd指令启动</p><p><img src="http://img.wcw231407.cn/202404041053215.png" alt="image-20240404105340082"></p><h2 id="服务注册到nacos"><a href="#服务注册到nacos" class="headerlink" title="服务注册到nacos"></a><strong>服务注册到nacos</strong></h2><p>1.引入spring-coloud-alilbaba依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-alibaba&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.注释之前在项目上相关的eureka配置</p><p>3.在user-service&amp;order-service添加nacos客户端的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;</span><br><span class="line">       </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>4.修改order-service&amp;user-service的配置文件，注释eureka的配置添加nacos配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    cloud:</span><br><span class="line">        nacos:</span><br><span class="line">            server-addr: localhost:8848</span><br></pre></td></tr></table></figure><h2 id="nacos服务的存储模型"><a href="#nacos服务的存储模型" class="headerlink" title="nacos服务的存储模型"></a><strong>nacos服务的存储模型</strong></h2><p><img src="http://img.wcw231407.cn/202404041055479.png" alt="image-20240404105546293"></p><p>服务集群调用的问题</p><ul><li>尽可能调用本地集群，跨集群调用延迟过高</li><li>本地集群不能访问时，再去访问其他集群</li></ul><p><img src="http://img.wcw231407.cn/202404041056445.png" alt="image-20240404105611313"></p><h2 id="服务集群配置"><a href="#服务集群配置" class="headerlink" title="服务集群配置"></a><strong>服务集群配置</strong></h2><p>增加服务集群配置，name随便命名：</p><p><img src="http://img.wcw231407.cn/202404041056346.png" alt="image-20240404105641265"></p><p>在nacos控制台就会看到两个集群的地方</p><p><img src="http://img.wcw231407.cn/202404041057345.png" alt="image-20240404105706187"></p><h2 id="根据集群负载均衡"><a href="#根据集群负载均衡" class="headerlink" title="根据集群负载均衡"></a><strong>根据集群负载均衡</strong></h2><p><strong>1.修改order-service中的application.yml,设置集群为HZ</strong></p><p>服务集群属性（来保证服务器优先访问的是本地集群）</p><p><img src="http://img.wcw231407.cn/202404041057442.png" alt="image-20240404105732321"></p><p><strong>2.然后order-service中设置负载均衡的IRule的NacosRule，这个规则优先会寻找与自己同集群的服务：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice:</span><br><span class="line">    ribbon:</span><br><span class="line">        NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule</span><br></pre></td></tr></table></figure><p><strong>3.注意将user-service的权重设置为1</strong></p><blockquote><p>NacosRule负载均衡策略：</p><p>​1.优先选择同集群服务实例列表</p><p>​2.本地集群找不到提供者，才去其它集群寻找，并且会报警告</p><p>​3.确定了可用实例列表后，在采用随机负载均衡挑选实例</p></blockquote><h2 id="根据权重负载均衡"><a href="#根据权重负载均衡" class="headerlink" title="根据权重负载均衡"></a><strong>根据权重负载均衡</strong></h2><p>1.在Nacos控制台可以设置实例的权重，首先选中实例后面的编辑按钮</p><p><img src="http://img.wcw231407.cn/202404041100364.png" alt="image-20240404110019247"></p><p>2.将权重设置为0.1，测试可以发现8080被访问到的频率大大降低</p><blockquote><p>实例的权重控制</p><p>​1.Nacos控制台可以设置实例的权重值，0-1之间</p><p>​2.同集群内的多个实例，权重越高被访问的频率越高</p><p>​3.权重设置为0则完全不会被访问</p></blockquote><h2 id="环境隔离-namespace"><a href="#环境隔离-namespace" class="headerlink" title="环境隔离 - namespace"></a><strong>环境隔离 - namespace</strong></h2><p>Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离</p><p><img src="http://img.wcw231407.cn/202404041102839.png" alt="image-20240404110205621"></p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a><strong>具体操作</strong></h3><p><img src="http://img.wcw231407.cn/202404041102365.png" alt="image-20240404110242251"></p><p><img src="http://img.wcw231407.cn/202404041103287.png" alt="image-20240404110302178"></p><p><img src="http://img.wcw231407.cn/202404041103402.png" alt="image-20240404110322274"></p><p><img src="http://img.wcw231407.cn/202404041103421.png" alt="image-20240404110337308"></p><p><img src="http://img.wcw231407.cn/202404041103924.png" alt="image-20240404110351774"></p><blockquote><p><strong>总结</strong>:</p><p>1.Nacos与eureka的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul><p>2.Nacos与Eureka的区别：</p><ul><li>Nacos支持服务端主动检测提供者：临时实例采用<strong>心跳模式</strong>，非临时实例采用<strong>主动检测模式</strong></li><li><strong>临时实例</strong>心跳不正常会被踢除，<strong>非临时实例</strong>则不会被剔除</li><li>Nacos支持服务列表变更的<strong>消息推送模式</strong>，服务列表更新更及时</li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用<strong>CP模式</strong>；Eureka采用<strong>AP方式</strong></li></ul><p>3.Nacos环境隔离</p><p>①每个namespace都有唯一id</p><p>②服务设置namespace时要写id而不是名称</p><p>③不同namespace下的服务互相不可见</p><p>nacos注意细节：</p><p><img src="http://img.wcw231407.cn/202404041106377.png" alt="image-20240404110635228"></p></blockquote><h2 id="Nacos的配置管理"><a href="#Nacos的配置管理" class="headerlink" title="Nacos的配置管理"></a><strong>Nacos的配置管理</strong></h2><h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a><strong>统一配置管理</strong></h3><p>1.回顾目前我们所学习的微服务架构</p><p><img src="http://img.wcw231407.cn/202404041108497.png" alt="image-20240404110806375"></p><p>2.配置更改热更新</p><p><img src="http://img.wcw231407.cn/202404041108519.png" alt="image-20240404110833392"></p><p><img src="http://img.wcw231407.cn/202404041109605.png" alt="image-20240404110941472"></p><p>1.在navos添加配置中心：</p><p><img src="http://img.wcw231407.cn/202404041110195.png" alt="image-20240404111004961"></p><p>在弹出的表单中填写信息</p><p><img src="http://img.wcw231407.cn/202404041110112.png" alt="image-20240404111027976"></p><p>配置获取步骤如下：</p><p><img src="http://img.wcw231407.cn/202404041110248.png" alt="image-20240404111057150"></p><p>加入nacos统一配置管理后：</p><p><img src="http://img.wcw231407.cn/202404041112312.png" alt="image-20240404111211187"></p><p>步骤：</p><p>1.引入Nacos的配置管理客户端依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.在userservice中的resource目录下添加一个bootstrap.yml文件，这个文件是引导文件，优先级高于application.yml:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: userservice #服务名称</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev #环境</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848 #nacos地址</span><br><span class="line">      config:</span><br><span class="line">        file-extension: yaml #文件后缀</span><br></pre></td></tr></table></figure><p>3.在controller中添加以下代码，测试nacos统一配置有没有生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span><br><span class="line">private String dateformat;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试时间格式是否已经注入</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@GetMapping(&quot;now&quot;)</span><br><span class="line">public String now()&#123;</span><br><span class="line">    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p><p>将配置交给Nacos管理步骤：</p><p>1.在nacos中添加配置文件</p><p>2.在微服务中引入nacos的config依赖</p><p>3.在微服务中添加bootstrap.yml，配置nacos地址、当前环境，服务名称和文件后缀名。这些决定了程序启动时去nacos读取哪个文件。</p></blockquote><h3 id="多环境配置共享"><a href="#多环境配置共享" class="headerlink" title="多环境配置共享"></a><strong>多环境配置共享</strong></h3><p>微服务启动时会从nacos读取多个配置文件：</p><ul><li>[spring.application.name]-[spring.profiles.active].yaml,例如：userservice-dev.yaml</li><li>[spring.application.name].yaml,例如：userservice.yaml</li></ul><p>无论profile如何变化。[spring.application.name].yaml这个文件一定会加载，因此多环境共享配置可以写入这个文件</p><p>1.在nacos中添加环境配置userservice.yaml</p><p><img src="http://img.wcw231407.cn/202404041123817.png" alt="image-20240404112357670"></p><p><img src="http://img.wcw231407.cn/202404041124544.png" alt="image-20240404112421381"></p><p>2.注入属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span><br><span class="line">public class PatternProperties &#123;</span><br><span class="line">    private String dateformat;</span><br><span class="line">    private String envShareValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在controller中添加下面的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;pros&quot;)</span><br><span class="line">public PatternProperties properties()&#123;</span><br><span class="line">    return properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发环境（dev）</p><p><img src="http://img.wcw231407.cn/202404041125224.png" alt="image-20240404112532135"></p><p><strong>测试在不同环境下的优先级</strong></p><p>1.在本地属性添加以下属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern:</span><br><span class="line">  name: 本地环境local</span><br></pre></td></tr></table></figure><p>2.在userservice-dev.yaml上写改为以上配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern:</span><br><span class="line">    dateformat: yyyy年MM月dd HH:mm:ss</span><br><span class="line">    name: 环境配置dev</span><br></pre></td></tr></table></figure><p>3.在userservice.yaml上改写为以上配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern:</span><br><span class="line">    envShareValue: 环境共享属性值</span><br><span class="line">    name: 环境共享default</span><br></pre></td></tr></table></figure><p>访问结果如下：</p><p><img src="http://img.wcw231407.cn/202404041127444.png" alt="image-20240404112713343"></p><p><img src="http://img.wcw231407.cn/202404041127461.png" alt="image-20240404112741334"></p><blockquote><p>微服务会从nacos读取的配置文件：</p><ul><li>[服务名]-[spring.profile.active].yaml,环境变量</li><li>[服务名].yaml,默认配置，多环境共享</li></ul><p>优先级：</p><p>[服务名]-[环境].yaml&gt;[服务名].yaml&gt;本地配置</p></blockquote><h3 id="Nacos集群搭建"><a href="#Nacos集群搭建" class="headerlink" title="Nacos集群搭建"></a><strong>Nacos集群搭建</strong></h3><p>Nacos生产环境下一定要部署为集群状态</p><p>集群结构图：</p><p><img src="http://img.wcw231407.cn/202404041128823.png" alt="image-20240404112851675"></p><h2 id="搭建集群的步骤："><a href="#搭建集群的步骤：" class="headerlink" title="搭建集群的步骤："></a><strong>搭建集群的步骤：</strong></h2><p>1.建立数据库表</p><p>2.安装nacos</p><p>3.写nacos的配置</p><p>4.启动nacos集群</p><p>5.ngnix的反向代理</p><h3 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a><strong>初始化数据库</strong></h3><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `config_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(255) DEFAULT NULL,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  `c_desc` varchar(256) DEFAULT NULL,</span><br><span class="line">  `c_use` varchar(64) DEFAULT NULL,</span><br><span class="line">  `effect` varchar(64) DEFAULT NULL,</span><br><span class="line">  `type` varchar(64) DEFAULT NULL,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_info_aggr   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_info_aggr` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(255) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `datum_id` varchar(255) NOT NULL COMMENT &#x27;datum_id&#x27;,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;内容&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_info_beta   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_info_beta` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `beta_ips` varchar(1024) DEFAULT NULL COMMENT &#x27;betaIps&#x27;,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_info_tag   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_info_tag` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `tag_id` varchar(128) NOT NULL COMMENT &#x27;tag_id&#x27;,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext NOT NULL COMMENT &#x27;content&#x27;,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  `src_user` text COMMENT &#x27;source user&#x27;,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL COMMENT &#x27;source ip&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = config_tags_relation   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `config_tags_relation` (</span><br><span class="line">  `id` bigint(20) NOT NULL COMMENT &#x27;id&#x27;,</span><br><span class="line">  `tag_name` varchar(128) NOT NULL COMMENT &#x27;tag_name&#x27;,</span><br><span class="line">  `tag_type` varchar(64) DEFAULT NULL COMMENT &#x27;tag_type&#x27;,</span><br><span class="line">  `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `nid` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  PRIMARY KEY (`nid`),</span><br><span class="line">  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = group_capacity   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `group_capacity` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">  `group_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;,</span><br><span class="line">  `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span><br><span class="line">  `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span><br><span class="line">  `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;</span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = his_config_info   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `his_config_info` (</span><br><span class="line">  `id` bigint(64) unsigned NOT NULL,</span><br><span class="line">  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `data_id` varchar(255) NOT NULL,</span><br><span class="line">  `group_id` varchar(128) NOT NULL,</span><br><span class="line">  `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;,</span><br><span class="line">  `content` longtext NOT NULL,</span><br><span class="line">  `md5` varchar(32) DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` varchar(50) DEFAULT NULL,</span><br><span class="line">  `op_type` char(10) DEFAULT NULL,</span><br><span class="line">  `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,</span><br><span class="line">  PRIMARY KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/******************************************/</span><br><span class="line">/*   数据库全名 = nacos_config   */</span><br><span class="line">/*   表名称 = tenant_capacity   */</span><br><span class="line">/******************************************/</span><br><span class="line">CREATE TABLE `tenant_capacity` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;,</span><br><span class="line">  `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;,</span><br><span class="line">  `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;,</span><br><span class="line">  `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;,</span><br><span class="line">  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;,</span><br><span class="line">  `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;,</span><br><span class="line">  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE `tenant_info` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,</span><br><span class="line">  `kp` varchar(128) NOT NULL COMMENT &#x27;kp&#x27;,</span><br><span class="line">  `tenant_id` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,</span><br><span class="line">  `tenant_name` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;,</span><br><span class="line">  `tenant_desc` varchar(256) DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;,</span><br><span class="line">  `create_source` varchar(32) DEFAULT NULL COMMENT &#x27;create_source&#x27;,</span><br><span class="line">  `gmt_create` bigint(20) NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `gmt_modified` bigint(20) NOT NULL COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `users` (</span><br><span class="line">    `username` varchar(50) NOT NULL PRIMARY KEY,</span><br><span class="line">    `password` varchar(500) NOT NULL,</span><br><span class="line">    `enabled` boolean NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `roles` (</span><br><span class="line">    `username` varchar(50) NOT NULL,</span><br><span class="line">    `role` varchar(50) NOT NULL,</span><br><span class="line">    UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE `permissions` (</span><br><span class="line">    `role` varchar(50) NOT NULL,</span><br><span class="line">    `resource` varchar(255) NOT NULL,</span><br><span class="line">    `action` varchar(8) NOT NULL,</span><br><span class="line">    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO users (username, password, enabled) VALUES (&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, TRUE);</span><br><span class="line"></span><br><span class="line">INSERT INTO roles (username, role) VALUES (&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;);</span><br></pre></td></tr></table></figure><h3 id="改nacos配置"><a href="#改nacos配置" class="headerlink" title="改nacos配置"></a><strong>改nacos配置</strong></h3><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="http://img.wcw231407.cn/202404041131214.png" alt="image-20240404113107059"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:8844</span><br><span class="line">127.0.0.1:8846</span><br><span class="line">127.0.0.1:8849</span><br></pre></td></tr></table></figure><p>建立三个文件夹nacos、nacos01、nacos02</p><p>nacos修改如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8844</span><br></pre></td></tr></table></figure><p>nacos02修改如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8846</span><br></pre></td></tr></table></figure><p>nacos03修改如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=8849</span><br></pre></td></tr></table></figure><p><strong>3.启动集群</strong></p><p><img src="http://img.wcw231407.cn/202404041134164.png" alt="image-20240404113414037"></p><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform=mysql</span><br><span class="line">db.num=1</span><br><span class="line">db.url.0=jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">db.user.0=root</span><br><span class="line">db.password.0=wcw231407</span><br></pre></td></tr></table></figure><blockquote><p>注意一定不要出现连续的端口号否者会出现端口占用问题</p></blockquote><h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a><strong>nginx反向代理</strong></h3><p>找到课前资料提供的nginx安装包：</p><p>链接：<a href="https://pan.baidu.com/s/1zZaC2BBClAVEkBtg8pIBpw?pwd=ksw1">https://pan.baidu.com/s/1zZaC2BBClAVEkBtg8pIBpw?pwd=ksw1</a><br>提取码：ksw1</p><p>解压到任意非中文目录下：</p><p><img src="http://img.wcw231407.cn/202404041142700.png" alt="image-20240404114236557"></p><p>修改conf&#x2F;nginx.conf文件，配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream nacos-cluster &#123;</span><br><span class="line">    server 127.0.0.1:8845;</span><br><span class="line">    server 127.0.0.1:8846;</span><br><span class="line">    server 127.0.0.1:8847;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location /nacos &#123;</span><br><span class="line">        proxy_pass http://nacos-cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:80 # Nacos地址</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h3><p>1.实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p><p>2.Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离 </p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud实用篇（三）——Ribbon负载均衡</title>
      <link href="/2024/04/02/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2024/04/02/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a><strong>Ribbon负载均衡</strong></h1><h2 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a><strong>负载均衡流程</strong></h2><p><img src="https://img.wcw231407.cn/202404021004656.png" alt="image-20240402100452405"></p><p>RestTamplate被@LoadBalanced标记表明要被Ribbon拦截处理</p><p><strong>追踪源码：</strong></p><p><strong>与黑马课程的源码有所不同</strong></p><p>首先进入LoadBalancerAutoConfigration自动装配类，这里可以发现传了一个final LoadBalancerInterceptor loadBalancerInterceptor的参数，通过List集合加入loadBalanceInterceptor，最终restTemplate设置次拦截器，RetryLoadBancerInterceptor又是什么呢？</p><p><img src="https://img.wcw231407.cn/202404021005832.png" alt="image-20240402100549611"></p><p>我们点LoadBalancerInterceptor进去看一下，可以看到他是实现ClientHttpRequestInterceptor的实现类，而ClientHttpRequestInterceptor是拦截我们http请求的拦截器</p><p><img src="http://img.wcw231407.cn/202404021006465.png" alt="image-20240402100609310"></p><p>我们再回到我们的LoadBalancerInterceptor，我们在这里可以看到它实现了Interptor方法</p><p><img src="https://img.wcw231407.cn/202404021006448.png" alt="image-20240402100634374"></p><p>进入我们所打的断点上</p><p><img src="http://img.wcw231407.cn/202404021007165.png" alt="image-20240402100724045"></p><p>这就说明当我们加了服务发现的注解时，我们会被我们的ribbot服务拦截</p><p><img src="https://img.wcw231407.cn/202404021007910.png" alt="image-20240402100755823"></p><p>以上拦截到了userservice用户服务名</p><p>当我们断点到retutrn （ClientHttpResponse）this.loadBalancer.excute(…)时，我们可以发现RibbonBalancer（Ribbon的负载均衡客户端）</p><p><img src="http://img.wcw231407.cn/202404021008061.png" alt="image-20240402100846958"></p><p>！！！</p><p>进入excute（）方法</p><p><img src="http://img.wcw231407.cn/202404021009798.png" alt="image-20240402100919685"></p><p>在进入RibbonLoadBalancerClient实现类</p><p><img src="http://img.wcw231407.cn/202404021009161.png" alt="image-20240402100942051"></p><p>我们可以发现上Server server &#x3D; this.getServer(loadBalancer,hint)就是我们实现负载均衡的方法</p><p><img src="http://img.wcw231407.cn/202404021010328.png" alt="image-20240402101019188"></p><p>总结:</p><p><img src="http://img.wcw231407.cn/202404021010933.png" alt="image-20240402101045772"></p>]]></content>
      
      
      <categories>
          
          <category> Ribbon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ribbon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud实用篇（二）——搭建eureka服务</title>
      <link href="/2024/03/30/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BAeureka%E6%9C%8D%E5%8A%A1/"/>
      <url>/2024/03/30/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BAeureka%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建eureka服务"><a href="#搭建eureka服务" class="headerlink" title="搭建eureka服务"></a><strong>搭建eureka服务</strong></h1><h2 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a><strong>搭建EurekaServer</strong></h2><h3 id="注册eureka自己本身"><a href="#注册eureka自己本身" class="headerlink" title="注册eureka自己本身"></a><strong>注册eureka自己本身</strong></h3><p>1.创建项目，引入spring-cloud-starter-neflix-eureka-server的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--eureka服务端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.编写启动类，添加@EnableEurekaServer注解</p><p>3.添加application.yml文件，编写下面的配置:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 10086 #服务端口</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: eurekaserver</span><br><span class="line">eureka:</span><br><span class="line">    client:</span><br><span class="line">        service:</span><br><span class="line">            defaultZone: http://127.0.0.1:10086/eureka/</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;spring:</span><br><span class="line">   application:</span><br><span class="line">       name: eurekaserver #eurekaserver</span><br><span class="line">&gt;eureka:</span><br><span class="line"> client:</span><br><span class="line">   service-url: #eureka的地址信息</span><br><span class="line">     defaultZone: http://127.0.0.1:10086/eurek</span><br></pre></td></tr></table></figure><p>上面就是注册自己的配置（因为自己也是一个微服务）</p></blockquote><p>下面这部分是最重要的，下面就是自己和其他服务被注册的信息</p><p><img src="http://img.wcw231407.cn/202403301654120.png" alt="image-20240330165435371"></p><h3 id="注册user-service"><a href="#注册user-service" class="headerlink" title="注册user-service"></a><strong>注册user-service</strong></h3><p>1.引入spring-cloud-start-netflix-eureka-client的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--eureka客户端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.在application.yml文件，编写下面的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: user-service</span><br><span class="line">eureka:</span><br><span class="line">    client:</span><br><span class="line">        service:</span><br><span class="line">            defaultZone: http://127.0.0.1:10086/eureka/</span><br></pre></td></tr></table></figure><h3 id="注册order-service"><a href="#注册order-service" class="headerlink" title="注册order-service"></a><strong>注册order-service</strong></h3><p>1.引入spring-cloud-start-netflix-eureka-client的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--eureka客户端依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2.在application.yml文件，编写下面的配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: user-service</span><br><span class="line">eureka:</span><br><span class="line">    client:</span><br><span class="line">        service:</span><br><span class="line">            defaultZone: http://127.0.0.1:10086/eureka/</span><br></pre></td></tr></table></figure><p>在此处遇到了一个bug，此bug由于配置文件是cv过来的所以存在不知名的空格影响了项目的允许</p><p>bug参考文章：<a href="https://blog.csdn.net/weixin_43464372/article/details/107637370">https://blog.csdn.net/weixin_43464372/article/details/107637370</a></p><blockquote><p>😊注意一定要自己写配置，不然有空格之类的会导致报错</p><p>目前高版本已经不用在客户端的启动端上添加@EnableEurekaClient注解</p></blockquote><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a><strong>服务发现</strong></h3><p>在注册的基础上</p><p>1.在orderService上修改远程调用接口</p><p>在注册的基础上</p><p>1.在orderService上修改远程调用接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//2.利用RestTemplate发起http请求，查询用户</span><br><span class="line">//2.1 url路径</span><br><span class="line">String url = &quot;http://localhost:8081/user/&quot;+order.getUserId();</span><br></pre></td></tr></table></figure><p>用服务名代替ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String url =&quot;http://order-service/user&quot;+order.getUserId();</span><br></pre></td></tr></table></figure><p>2.在启动类上RestTemplate上添加注解负载均衡注解（@LoadBalanced）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public stestTemplate()&#123;</span><br><span class="line">    return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此服务注册完毕</p><p>发出了三次申请</p><p>两次在端口为8082的提供者</p><p><img src="http://img.wcw231407.cn/202403301702434.png" alt="image-20240330170203275"></p><p>一打在了端口为8080的提供者上</p><p><img src="http://img.wcw231407.cn/202403301702999.png" alt="image-20240330170233871"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> eureka </tag>
            
            <tag> 服务注册 </tag>
            
            <tag> 服务发现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud实用篇（一）</title>
      <link href="/2024/03/28/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/03/28/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a><strong>SpringCloud</strong></h1><ul><li>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></li><li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验：</li></ul><p><img src="http://img.wcw231407.cn/202403281952981.png" alt="image-20240328195254718"></p><ul><li>SpringCloud与SpringBoot的版本兼任关系如下：</li></ul><p><img src="http://img.wcw231407.cn/202403281953525.png" alt="image-20240328195323436"></p><h1 id="服务拆分及远程调用"><a href="#服务拆分及远程调用" class="headerlink" title="服务拆分及远程调用"></a><strong>服务拆分及远程调用</strong></h1><p><strong>拆分注意事项</strong></p><p>1.不同微服务，不要重复开发相同业务</p><p>2.微服务数据独立，不要访问其他微服务的数据库</p><p>3.微服务可以将自己的业务接口暴露为接口，供其他微服务调用</p><p><strong>导入服务拆分Demo</strong></p><p>1.导入课前资料提供的工程：cloud-demo</p><p>链接：<a href="https://pan.baidu.com/s/1QueUAbzed1NBUEUdrKskkg?pwd=ksw1">https://pan.baidu.com/s/1QueUAbzed1NBUEUdrKskkg?pwd=ksw1</a><br>提取码：ksw1<br>2.项目结构</p><p><img src="http://img.wcw231407.cn/202403281956362.png" alt="image-20240328195655304"></p><p>3.将课前资料准备的sql导入数据库</p><p>链接：<a href="https://pan.baidu.com/s/1QueUAbzed1NBUEUdrKskkg?pwd=ksw1">https://pan.baidu.com/s/1QueUAbzed1NBUEUdrKskkg?pwd=ksw1</a><br>提取码：ksw1</p><blockquote><p>总结</p><p>​        1.微服务需要根据业务模块拆分，做到单一职责，不要重复开发相同业务</p><p>​2.微服务可以将业务暴露为接口，供其他微服务使用</p><p>​3.不同微服务都应该有自己独立的数据库</p></blockquote><h1 id="服务拆分-服务远程调用"><a href="#服务拆分-服务远程调用" class="headerlink" title="服务拆分-服务远程调用"></a><strong>服务拆分-服务远程调用</strong></h1><p>使用远程调用方式查询到用户信息</p><p><img src="http://img.wcw231407.cn/202403281959196.png" alt="image-20240328195926030"></p><p>可以使用RestTemplate发送请求， RestTemplate 是发送各种HTTP请求，那么就可以使用 RestTemplate 发起远程http请求：</p><p>在order_service 模块中的启动配置类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 在启动配置类注入 RestTemplate bean容器</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  @Bean</span><br><span class="line">  public RestTemplate restTemplate() &#123;</span><br><span class="line">      return new RestTemplate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>修改查询实现方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">    private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public Order queryOrderById(Long orderId) &#123;</span><br><span class="line">        // 1.查询订单</span><br><span class="line">        Order order = orderMapper.findById(orderId);</span><br><span class="line">        // 2利用RestTemplate发送Http请求，查询用户</span><br><span class="line">        // 2.1 url的地址为user-service模块启动的端口，因为是向user-service发送请求</span><br><span class="line">        String url = &quot;http://localhost:8081/user/&quot; + order.getUserId();</span><br><span class="line">        // 发送请求，完成远程调用</span><br><span class="line">        User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">        // 封装user</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        // 4.返回</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a><strong>Eureka</strong></h1><h2 id="eureka-消费者与提供者"><a href="#eureka-消费者与提供者" class="headerlink" title="eureka-消费者与提供者"></a><strong>eureka-消费者与提供者</strong></h2><p>提供者：一次业务中，被其他微服务调用的服务 （提供接口给其他微服务，接口被调用了）</p><p>消费者：一次业务中，调用其他微服务的服务（调用其他微服务提供的接口，调用别人的接口）</p><p>上面的demo中，user就是服务提供者（接口被调用），order就是服务消费者（调用了别人的接口）</p><p><img src="http://img.wcw231407.cn/202403282001935.png" alt="image-20240328200131872"></p><blockquote><p>思考：服务A调用服务B，服务B调用服务C，那么服务B是什么角色？</p><p>主要是要看怎么调用</p><ol><li><p>如果是服务B调用了服务C，那么服务B就是服务消费者</p><p>2.如果是服务B被服务A调用了，那么服务B就是服务提供者</p></li></ol></blockquote><blockquote><p><strong>总结</strong></p><p>服务调用关系</p><p><img src="http://img.wcw231407.cn/202403282002271.png" alt="image-20240328200257184"></p><ul><li><p>服务提供者：暴露接口给其它微服务调用</p></li><li><p>服务消费者：调用其它微服务提供的接口</p></li><li><p>提供者与消费者角色其实是<strong>相对</strong>的</p></li><li><p>一个服务可以同时是服务提供者和服务消费者</p></li></ul></blockquote><h2 id="eureka原理分析"><a href="#eureka原理分析" class="headerlink" title="eureka原理分析"></a><strong>eureka原理分析</strong></h2><blockquote><p><strong>调用出现的问题：</strong></p><ol><li><strong>服务消费者该如何获取服务提供者的地址信息？</strong></li><li><strong>如果有多个服务提供者，消费者该如何选择？</strong></li><li><strong>消费者如何得知服务者的健康状态？</strong></li></ol></blockquote><p><img src="http://img.wcw231407.cn/202403282004786.png" alt="image-20240328200453699"></p><h3 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a><strong>Eureka的作用</strong></h3><p><img src="http://img.wcw231407.cn/202403282005385.png" alt="image-20240328200528201"></p><p>再来回答上面第一部分的遗留问题：</p><p>1.消费者该如何获取服务提供者具体信息？</p><ul><li><p>服务提供者启动时向eureka注册自己的信息</p></li><li><p>eureka保存这些信息</p></li><li><p>消费者根据服务名称向eureka拉取提供者信息</p></li></ul><p>2.如果有多个服务提供者，消费者该如何选择？</p><ul><li>服务消费者利用负载均衡算法，从服务列表中挑选一个</li></ul><p>3.消费者如何感知服务提供者健康状态？</p><ul><li><p>服务提供者会每隔30秒向EurekaServer发送心跳请求，报告健康状态</p></li><li><p>eureka会更新记录服务列表信息，心跳不正常会被剔除</p></li><li><p>消费者就可以拉取到最新的信息</p></li></ul><blockquote><p>在Eureka架构中，微服务角色有两类：</p><p>1.EurekaServer：服务端，注册中心</p><ul><li><p>记录服务信息</p></li><li><p>心跳监控</p></li></ul><p>2.EurekaClient：客户端</p><p>Provider：服务提供者，例如案例中的 user-service</p><ul><li><p>注册自己的信息到EurekaServer</p></li><li><p>每隔30秒向EurekaServer发送心跳</p></li></ul><p>consumer：服务消费者，例如案例中的 order-service</p><ul><li><p>根据服务名称从EurekaServer拉取服务列表</p></li><li><p>基于服务列表做负载均衡，选中一个微服务后发起远程调用</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> EurekaServer </tag>
            
            <tag> Eureka </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ant Design Pro V5项目无法启动问题解决</title>
      <link href="/2024/03/27/Ant%20Design%20Pro%20V5%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/03/27/Ant%20Design%20Pro%20V5%E9%A1%B9%E7%9B%AE%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>问题：</p><p>​    今天准备使用一下Ant Design Pro做项目，全程按照官网文档步骤来进行项目搭建，在这里我使用的node.js版本是16.15.0，npm版本是8.5.5，当我第一次ant design pro来做一个属于我自己的管理系统时突然发现ant design竟然运行不了，试n个方法后…,终于找到了解决方案</p><p><img src="http://img.wcw231407.cn/202403271836503.png" alt="40db0d7f0dd543ce84f23d4f8233adf6.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>解决方案1：</p><p>​    删除index.md，把依赖删掉和umi文件夹删除，yarn(yarnpkg代替也行)一下，然后运行</p><p>解决方式2：</p><p>​    umi版本选择4(不太建议使⽤ umi 4 了，兼容性不好。可以忽略， 不影响后续的学习)</p><p><img src="http://img.wcw231407.cn/202403271837992.png" alt="ce17ae27a8234673888142b4fc3c7deb.png"></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ant design pro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每次请求sessionId变化</title>
      <link href="/2024/03/27/%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82sessionId%E5%8F%98%E5%8C%96/"/>
      <url>/2024/03/27/%E6%AF%8F%E6%AC%A1%E8%AF%B7%E6%B1%82sessionId%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 引言：花了一晚上的时间，终于把问题解决了，一开始后端做完后,用apifox所有接口测试都是可以的,但当前端跑起来后发现接收不到后端的数据。</p></blockquote><p>当我写完前后端，主页面和获取当前页面信息接口后，配置了cros注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>我一开始使用接口文档做了后端接口测试，测试发现当访问主页面时前端能成功接受到数据,本以为皆大欢喜了，在当我接入获取当前信息接口时并测试时发现获取不到信息，我又使用apifox进行测试接口能够获取到数据，于是我使用F12进行调试。</p><p>登录：</p><p><img src="http://img.wcw231407.cn/202403271832481.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>获取当前信息：</p><p><img src="http://img.wcw231407.cn/202403271832630.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>浏览器第一次访问时会获得sessionid存在cookie中,后续访问如果有session存着,获取当前信息时会直接用，但是并没有，由上面可以知道后端重新返回了一个sessionId给前端，导致访问后端时由于sessionId不匹配，最终无法获取到登录账号的当前用户信息。</p><p><strong>然后又经过多次调试,最终解决了这个问题,下面把方案放上来：</strong></p><p>首先是前端,在vue的main.js中加上这个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = true;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在后端用配置类解决跨域问题</p><p>另一方面是corsfilter,这个会先于拦截器执行,解决跨域问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.wcw.usercenter.config;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.cors.CorsConfiguration;</span><br><span class="line">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line">import org.springframework.web.filter.CorsFilter;</span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line">    private CorsConfiguration corsConfig()&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = new CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedHeader(&quot;*&quot;); //允许所有请求头</span><br><span class="line">        corsConfiguration.addAllowedMethod(&quot;*&quot;); //允许所有请求方法</span><br><span class="line">        corsConfiguration.setAllowCredentials(true);//是否允许证书</span><br><span class="line">        corsConfiguration.addAllowedOrigin(&quot;http://localhost:5173/&quot;); //允许所有的请求类型</span><br><span class="line">        corsConfiguration.setMaxAge(3600L);</span><br><span class="line">        return corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter()&#123;</span><br><span class="line">        //存储request与跨域配置信息的容器，基于url的映射</span><br><span class="line">        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(&quot;/**&quot;,corsConfig());</span><br><span class="line">        return new CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket</title>
      <link href="/2024/03/27/WebSocket/"/>
      <url>/2024/03/27/WebSocket/</url>
      
        <content type="html"><![CDATA[<blockquote><p>什么是消息推送（push）</p><p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p><p>消息推送(push)通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备APP进行的主动消息推送。</p><p>消息推送一般又分为web端消息推送和移动端消息推送。</p></blockquote><h1 id="消息推送常见方式"><a href="#消息推送常见方式" class="headerlink" title="消息推送常见方式"></a>消息推送常见方式</h1><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p>浏览器以指定的时间间隔向服务器发出HTTP请求，服务器实时返回数据给浏览器</p><p><img src="http://img.wcw231407.cn/202403271827767.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>浏览器浏览器发出ajax请求，服务器端接收到请求，会阻塞请求直到有数据或者超时才返回</p><p><img src="http://img.wcw231407.cn/202403271827597.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="SSE（服务发送事件）"><a href="#SSE（服务发送事件）" class="headerlink" title="SSE（服务发送事件）"></a>SSE（服务发送事件）</h2><ul><li>SSE在服务器和客户端之间打开一个单向通道</li><li>服务器响应的不再是一次性的数据包，而是text&#x2F;event-stream类型的数据流消息</li><li>服务器有数据变更时将数据流式传输客户端</li></ul><p><img src="http://img.wcw231407.cn/202403271827390.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>websocket是一种在基于TCP连接上进行全双工通信的协议</p><p><img src="http://img.wcw231407.cn/202403271827475.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>全双工：允许数据在两个方向上同时传输。</p><p>半双工：允许数据在两个方向上传输，但是同一个时间段内只允许一个方向传输</p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><h2 id="WebSocket介绍"><a href="#WebSocket介绍" class="headerlink" title="WebSocket介绍"></a>WebSocket介绍</h2><p>Websocket是一种网络通信协议。RFC6455定义它的通信标准。</p><p>WebSocket是一种HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议</p><blockquote><p>HTTP协议是一种无状态的、无连接的、单向的应用层协议。它采取了请求&#x2F;响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p><p>这种通信模型有一个弊端：HTTP协议无法实现服务器主动向客户端发起消息。</p><p>这种单向请求的特点，注定如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数Web应用程序将通过频繁的异步AJAX请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停的连接，或者HTTP连接始终打开）</p></blockquote><p><strong>http协议与webSocket区别：</strong></p><p>http协议：</p><p><img src="http://img.wcw231407.cn/202403271827311.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>websocket协议：</p><p><img src="http://img.wcw231407.cn/202403271827697.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="webSocket协议"><a href="#webSocket协议" class="headerlink" title="webSocket协议"></a>webSocket协议</h2><p>本协议有两部分：握手和数据传输。</p><p>握手是基于http协议的。</p><p>来自客户端的握手看起来像如下形式：</p><p><img src="http://img.wcw231407.cn/202403271827392.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>来自服务器的握手看起来像如下形式（响应）：</p><p><img src="http://img.wcw231407.cn/202403271827751.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>响应行为101说明建立连接成功</p><p>字段说明：</p><p><img src="http://img.wcw231407.cn/202403271827193.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="客户端（浏览器）实现"><a href="#客户端（浏览器）实现" class="headerlink" title="客户端（浏览器）实现"></a>客户端（浏览器）实现</h2><p>websocket对象</p><p>实现webSockets的Web浏览器将通过WebSocketu对象公开所有必须的客户端功能（主要指支持Html5的浏览器）。</p><p>以下API用于创建WebSocket对象：</p><p>var ws &#x3D; new WebSocket(url);</p><p>参数url格式说明: ws:&#x2F;&#x2F;ip地址:端口号&#x2F;资源名称</p><p>websocket事件</p><p>webSocket对象的相关事件</p><p><img src="http://img.wcw231407.cn/202403271827536.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>WebSocket方法</p><p>WebSocket对象的相关方法：</p><p><img src="http://img.wcw231407.cn/202403271827755.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>Tomcat的7.0.5版本开始支持WebSocket，并且实现了JavaWebket规范（JSR356）</p><p>Java WebSocket应用由一系列的websocketEndpoint组成。Endpoint是一个java对象，代表WebSocket链接的一端，对于服务端，我们可以通过两种方式定义Endpoint：</p><ul><li>第一种是编程式，即继承类javax.websocket.Endpoint并实现其方法。</li><li>第二种是注解式，即定义一个POJO，并添加@ServerEndpoint相关注解</li></ul><p>Endpoint实例在WebSocket握手时创建，并在客户端与服务端链接关闭时结束。在Endpoint接口中明确定义了与其生命周期相关的方法，规范实现者确保生命周期的各个阶段调用实例相关的方法。生命周期如下：</p><p><img src="http://img.wcw231407.cn/202403271827091.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>服务端如何接收客户端发送的数据呢？</strong></p><p>通过Session添加MessageHandler消息处理器来接收消息，当采用注解方式定义Endpoint时，我们可以通过@onMessage注解指定接收消息的方法</p><p><strong>服务器端如何推送数据给客户端呢？</strong></p><p>发送消息则由RemoteEndpoint完成，其实例由Session维护，使用情况，我们可以通过Session.getBasicRemote获取同步消息发送的实例，然后调用其sendXxx（）方法就可以发送消息，可以通过Session.getAsyncRemote获取异步消息发送实例。</p>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC（下）</title>
      <link href="/2024/03/27/JDBC%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2024/03/27/JDBC%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC连接池原理"><a href="#JDBC连接池原理" class="headerlink" title="JDBC连接池原理"></a>JDBC连接池原理</h1><p>首先看如下图：</p><p><img src="http://img.wcw231407.cn/202403271816320.png" alt="5b06a2a3346e492caa02e78fe70c65a5.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>图片可能有点丑！！！</p><p>（注：上面方块是在连接池里的连接资源，下面火柴人是用户）</p><blockquote><p>1、池子中，我们有4个连接的资源<br> 2、我们有5个用户<br> 3、当我们用户需要的时候呢，就把连接给用户，此时图就成这样了</p></blockquote><p><img src="http://img.wcw231407.cn/202403271816430.png" alt="aea702cf712f4d6cad1f42b2a8e5a343.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>1、如上图所示，一个用户则用一个连接</p><p>2、多出来用户来并没有连接可以用</p><ul><li>那么我们有什么好的处理方式呢？？？</li></ul><p>​    （1）、等其他用户用完，我再用</p><p>​    （2）、或者重新创建一个连接给连接池，连接池再分配给我们的用户（如图）</p></blockquote><p><img src="http://img.wcw231407.cn/202403271816240.png" alt="7310f2d627fd4d17a0f4cd34d4f89635.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>#当用户用完之后，会把连接还给连接池，并不关闭</p></blockquote><h1 id="实例-（C3P0连接池）"><a href="#实例-（C3P0连接池）" class="headerlink" title="实例 （C3P0连接池）"></a>实例 （C3P0连接池）</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作 :"></a>准备工作 :</h2><p>​    1.去谷歌搜索JDBC C3P0，下载C3P0连接池的jar包，解压后，在<strong>lib目录下</strong>可以找到两个jar包</p><p>​    2.同之前导入mysql的jar包类似，将C3P0的这两个jar包拷贝到IDEA中存放jar包的目录下，右键jar包，选择“**Add as Library…**”将jar加入到项目。 加入成功后可以看到jar包下的子目录</p><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>C3P0_Demo1类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package connection_pool.c3p0;</span><br><span class="line"> </span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"> </span><br><span class="line">import java.beans.PropertyVetoException;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @author : Cyan_RA9</span><br><span class="line"> * @version : 21.0</span><br><span class="line"> */</span><br><span class="line">public class C3P0_Demo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, PropertyVetoException, SQLException &#123;</span><br><span class="line">        //创建数据源对象</span><br><span class="line">        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource();</span><br><span class="line">        //从properties配置文件中获取相关信息</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(new FileInputStream(&quot;src/api/connection/mysql.properties&quot;));</span><br><span class="line">        String driver = properties.getProperty(&quot;driver&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line"> </span><br><span class="line">        //通过ComboPooledDataSource类的setXxx方法来设置信息</span><br><span class="line">        comboPooledDataSource.setDriverClass(driver);</span><br><span class="line">        comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">        comboPooledDataSource.setUser(user);</span><br><span class="line">        comboPooledDataSource.setPassword(password);</span><br><span class="line">        //设置连接池初始连接数</span><br><span class="line">        comboPooledDataSource.setInitialPoolSize(10);</span><br><span class="line">        //设置连接池最大连接数</span><br><span class="line">        comboPooledDataSource.setMaxPoolSize(50);</span><br><span class="line">        /**</span><br><span class="line">         * 初始连接数指连接池被创建后初始化连接的数量；</span><br><span class="line">         * 最大连接数指连接池内的连接最多50个；</span><br><span class="line">         * 当50个连接全部被使用时，新的连接请求就会进入等待队列。</span><br><span class="line">         */</span><br><span class="line"> </span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 5000; ++i) &#123;</span><br><span class="line">            //获取连接</span><br><span class="line">            Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line"> </span><br><span class="line">            //释放资源（仅仅是取消了对连接池内连接的引用，连接本身不受影响。</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line"> </span><br><span class="line">        System.out.println(&quot;使用C3P0连接池后，连接MySQL5000次需要&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="通过配置文件"><a href="#通过配置文件" class="headerlink" title="通过配置文件"></a>通过配置文件</h2><p>c3p0-config.xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;c3p0-config&gt;</span><br><span class="line">    &lt;!-- 数据源名称，代表连接池 --&gt;</span><br><span class="line">    &lt;named-config name=&quot;Cyan&quot;&gt;</span><br><span class="line">        &lt;!-- 配置数据库用户名 --&gt;</span><br><span class="line">        &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;</span><br><span class="line">        &lt;!-- 配置数据库密码 --&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;</span><br><span class="line">        &lt;!-- 配置数据库URL --&gt;</span><br><span class="line">        &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbc_ex&lt;/property&gt;</span><br><span class="line">        &lt;!-- 配置数据库驱动 --&gt;</span><br><span class="line">        &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;</span><br><span class="line">        &lt;!-- 数据库连接池一次性向数据库要多少个连接对象 --&gt;</span><br><span class="line">        &lt;property name=&quot;acquireIncrement&quot;&gt;20&lt;/property&gt;</span><br><span class="line">        &lt;!-- 初始化连接数 --&gt;</span><br><span class="line">        &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;</span><br><span class="line">        &lt;!-- 最小连接数 --&gt;</span><br><span class="line">        &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt;</span><br><span class="line">        &lt;!-- 最大连接数。Default: 15 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxPoolSize&quot;&gt;50&lt;/property&gt;</span><br><span class="line">        &lt;!-- 可连接的最多命令对象数 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxStatements&quot;&gt;5&lt;/property&gt;</span><br><span class="line">        &lt;!-- 每个连接对象可连接的最多命令对象数 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;2&lt;/property&gt;</span><br><span class="line">        &lt;!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 通过多线程实现多个操作同时被执行。Default:3 --&gt;</span><br><span class="line">        &lt;property name=&quot;numHelperThreads&quot;&gt;3&lt;/property&gt;</span><br><span class="line">        &lt;!--用户修改系统配置参数执行前最多等待300秒。Default: 300 --&gt;</span><br><span class="line">        &lt;property name=&quot;propertyCycle&quot;&gt;3&lt;/property&gt;</span><br><span class="line">        &lt;!-- 获取连接超时设置 默认是一直等待单位毫秒 --&gt;</span><br><span class="line">        &lt;property name=&quot;checkoutTimeout&quot;&gt;1000&lt;/property&gt;</span><br><span class="line">        &lt;!--每多少秒检查所有连接池中的空闲连接。Default: 0 --&gt;</span><br><span class="line">        &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;3&lt;/property&gt;</span><br><span class="line">        &lt;!--最大空闲时间,多少秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxIdleTime&quot;&gt;10&lt;/property&gt;</span><br><span class="line">        &lt;!--配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。 --&gt;</span><br><span class="line">        &lt;property name=&quot;maxIdleTimeExcessConnections&quot;&gt;5&lt;/property&gt;</span><br><span class="line">        &lt;!--两次连接中间隔时间，单位毫秒。Default: 1000 --&gt;</span><br><span class="line">        &lt;property name=&quot;acquireRetryDelay&quot;&gt;1000&lt;/property&gt;</span><br><span class="line">        &lt;!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default: null --&gt;</span><br><span class="line">        &lt;property name=&quot;automaticTestTable&quot;&gt;Test&lt;/property&gt;</span><br><span class="line">        &lt;!-- 获取connection时测试是否有效 --&gt;</span><br><span class="line">        &lt;property name=&quot;testConnectionOnCheckin&quot;&gt;true&lt;/property&gt;</span><br><span class="line">    &lt;/named-config&gt;</span><br><span class="line">&lt;/c3p0-config&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>C3P0_Demo2类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package connection_pool.c3p0;</span><br><span class="line"> </span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"> </span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"> </span><br><span class="line">public class C3P0_Demo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">        ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(&quot;Cyan&quot;);</span><br><span class="line"> </span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">            Connection connection = comboPooledDataSource.getConnection();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;通过配置文件设置参数后，C3P0连接池连接5000次MySQL耗时&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC（中）</title>
      <link href="/2024/03/27/JDBC%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2024/03/27/JDBC%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义JDBCUtil工具"><a href="#自定义JDBCUtil工具" class="headerlink" title="自定义JDBCUtil工具"></a>自定义JDBCUtil工具</h1><p>前面Jdbc的基本使用使用已经讲得差不多了，但如果我们经常要创建连接，关闭连接的话，那么每次都要写重复的代码，显然这样非常的麻烦，为了避免这种情况，编写了一个JdbcUtil工具类，如下。</p><h2 id="1-db-properties文件"><a href="#1-db-properties文件" class="headerlink" title="1.db.properties文件"></a>1.db.properties文件</h2><p>用于放置驱动名称，连接数据库地址，数据库账号和密码。(db.properties要放在src或者默认会加载的目录下，不要放在包下面了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#MySQL连接配置</span><br><span class="line">mysqlDriver=com.mysql.jdbc.Driver</span><br><span class="line">mysqlURL=jdbc:mysql://localhost:3306/jdbcstudy?characterEncoding=utf8&amp;useSSL=false</span><br><span class="line">mysqlUser=root</span><br><span class="line">mysqlPwd=123456</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="2-创建JdbcUtil工具类"><a href="#2-创建JdbcUtil工具类" class="headerlink" title="2.创建JdbcUtil工具类"></a>2.创建JdbcUtil工具类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import javax.management.RuntimeMBeanException;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class JdbcUtil &#123;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String user;</span><br><span class="line">    private static String password;</span><br><span class="line">    private static String driver;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Properties properties = new Properties();</span><br><span class="line">            properties.load(new FileInputStream(&quot;src\\DateBase_select\\db.properties&quot;));</span><br><span class="line">            url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">            user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">            password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">            driver = properties.getProperty(&quot;driver&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return DriverManager.getConnection(url,user,password);</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void close(ResultSet resultSet,Statement statement, Connection connection)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            resultSet.close();</span><br><span class="line">            statement.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void close(Statement statement, Connection connection)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-JdbcUtil的简单示例："><a href="#3-JdbcUtil的简单示例：" class="headerlink" title="3.JdbcUtil的简单示例："></a>3.JdbcUtil的简单示例：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Connection con = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        //调用JdbcUtil来创建连接</span><br><span class="line">        con = JdbcUtil.getConnection();</span><br><span class="line">        String sql = &quot;select * from t_user&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            ps = con.prepareStatement(sql);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            while (rs.next()) &#123;</span><br><span class="line">                System.out.print(&quot;编号：&quot; + rs.getInt(1) + &quot;;&quot;);</span><br><span class="line">                System.out.print(&quot;姓名：&quot; + rs.getString(2) + &quot;;&quot;);</span><br><span class="line">                System.out.print(&quot;密码：&quot; + rs.getString(3) + &quot;;&quot;);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JdbcUtil.close(con, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>小伙伴会发现一个地方，工具类<code>close()</code>的参数中有一个<code>Statement</code>，这里用<code>Statement</code>而不用<code>PreparedStatement</code>是因为：<code>Statement</code>是<code>PreparedStatement</code>的<code>父接口</code>，<code>Statement</code>可以兼容这两种不同的对象。</p></blockquote><h1 id="JDBC的事务"><a href="#JDBC的事务" class="headerlink" title="JDBC的事务"></a>JDBC的事务</h1><blockquote><h2 id="事务的基本概念"><a href="#事务的基本概念" class="headerlink" title="事务的基本概念"></a>事务的基本概念</h2></blockquote><p>什么是事务呢？</p><p>​    <strong>事务是若干个SQL语句构成的一个操作序列，这些操作表示一个完整的功能，并且需要保证功能的完整性，因此要求在该事务中要求所有的sql要么都执行，要么都不执行，是一个不可分割的整体单位。（简单来说就是由多个小任务的组成的任务）</strong></p><blockquote><h2 id="事务的四个基本要素（ACID）"><a href="#事务的四个基本要素（ACID）" class="headerlink" title="事务的四个基本要素（ACID）"></a>事务的四个基本要素（ACID）</h2></blockquote><ul><li>原子性（Atomicity）：事务是一个不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作出错，回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态。</li><li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</li><li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱结束前，B不能向这张卡转账。</li><li>持久性（Durability）：事务一旦被提交后，事务对数据库的所有更新将被永远保存到数据库，不能回滚。</li></ul><h2 id="事务并发产生的问题"><a href="#事务并发产生的问题" class="headerlink" title="事务并发产生的问题"></a>事务并发产生的问题</h2><ul><li><strong>丢失修改</strong>：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。</li></ul><p><img src="http://img.wcw231407.cn/202403271811755.png" alt="5e759cd12aed423587a17258e107cfb4.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>T1和T2同时修改一条数据，T2的修改覆盖了T1的修改；　如果在T1之后第T2才能进行更改，则可以避免该问</p><ul><li><strong>脏读</strong>：事务A读取了事务B更新并且未提交的数据，然后B回滚操作，那么A读取到的数据是脏数据</li></ul><p><img src="http://img.wcw231407.cn/202403271811945.png" alt="d8e6fb0c2d6a4a2bbaeb3a8935d62191.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>一个编辑人员T1正在更改电子文档。在更改过程中，另一个编辑人员T2复制了该文档（该复本包含到目前为止所做的全部更改）并将其分发给预期的用户。此后，第一个编辑人员T1认为所做的更改是错误的，于是删除了所做的编辑并保存了文档。分发给用户的文档包含不再存在的编辑内容，并且这些编辑内容应认为从未存在过。如果在第一个编辑人员确定最终更改前任何人都不能读取更改的文档，则可以避免该问题。</p><ul><li><strong>不可重复读</strong>：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li></ul><p><img src="http://img.wcw231407.cn/202403271811011.png" alt="a9f4710156854dff97527e4c014aaff3.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变！这种现象就叫做“不可重复读”。指事务T2读取数据后，事务T1执行更新操作，使T1和T2无法读取前一次结果。</p><ul><li><strong>幻读</strong>：事务A从一个表中读取了一个字段，然后B在该表中<strong>插入&#x2F;删除</strong>了一些新的行。 之后, 如果 A 再次读取同一个表, 就会多&#x2F;少几行，就好像发生了幻觉一样，这就叫幻读。</li></ul><p><img src="http://img.wcw231407.cn/202403271811861.png" alt="c361723c5e5f45faba5f5d7fd2a10629.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p><em>事务t2读取到了事务t1体提交的新增、删除数据，不符合隔离性。</em>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul><li>读未提交（read-uncommitted）：允许A事务读取其他事务未提交和已提交的数据</li><li>不可重复读（read-committed）：只允许A事务读取其他事务已提交的数据</li><li>可重复读（repeatable-read）：确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新；注意：mysql中使用了MVCC多版本控制技术，在这个级别也可以避免幻读。</li><li>串行化（serializable）：确保事务可以从一个表中读取相同的行，相同的记录。在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作（效率非常低，基本不用）</li></ul><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><h2 id="事务中需要使用的API方法"><a href="#事务中需要使用的API方法" class="headerlink" title="事务中需要使用的API方法"></a>事务中需要使用的API方法</h2><ol><li><code>connection.setAutoCommit(false); </code>&#x2F;&#x2F; 取消事务的自动提交</li><li><code>connection.rollback(); </code>&#x2F;&#x2F; 事务回滚<br>参数为空的时候，回滚到事务的开始。如果有参数的时候，返回到回滚点。</li><li><code>connection.commit(); </code>&#x2F;&#x2F; 提交结果给数据库</li></ol><h2 id="事务使用实例"><a href="#事务使用实例" class="headerlink" title="事务使用实例"></a>事务使用实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Transaction &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        String sql1 = &quot;update `actor` set salary = salary + 100 where `name` = &#x27;小王&#x27;&quot;;</span><br><span class="line">        String sql2 = &quot;update `actor` set salary = salary - 100 where `name` = &#x27;小李&#x27;&quot;;</span><br><span class="line">        PreparedStatement preparedStatement = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JdbcUtil.getConnection();</span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql1);</span><br><span class="line">            preparedStatement.executeUpdate();</span><br><span class="line">            int i = 1/0;</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql2);</span><br><span class="line">            preparedStatement.executeUpdate();</span><br><span class="line">            connection.commit();</span><br><span class="line">        &#125; catch (SQLException throwables) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.rollback();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            JdbcUtil.close(preparedStatement,connection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>注意：mysql中默认情况下，一个sql独占一个事务，且自动提交，从以上jdbc学习就可以看得出来</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p>​    idea连接数据库问题：</p><p>​    1.配置时lib未导入连接数据库的架包</p><p>​    2.驱动版本与数据库版本对不上</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC（上）</title>
      <link href="/2024/03/27/JDBC%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2024/03/27/JDBC%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC"></a>什么是JDBC</h1></blockquote><p>Java 数据库连接 （JDBC） API 是 Java 编程语言与各种数据库 SQL 数据库和其他表格数据源（如电子表格或平面文件）之间独立于数据库的连接之间的行业标准。JDBC API 为基于 SQL 的数据库访问提供了调用级 API。JDBC给数据库的连接搭建了桥梁，然后再根据不同的数据库厂商实现JDBC接口的驱动，就可以轻松的连接各种关系型数据库了。</p><p><img src="http://img.wcw231407.cn/202403271803388.png" alt="eb744833b219497ea5a7bdc62073cb4d.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><h1 id="JDBC的重要性"><a href="#JDBC的重要性" class="headerlink" title="JDBC的重要性"></a>JDBC的重要性</h1></blockquote><p>JDBC是Java操作数据库的唯一方式，所以说JDBC非常的重要，尽管我们后面会学习框架，但是这是框架的底层必定都封装了JDBC的代码。</p><blockquote><h1 id="开始准备"><a href="#开始准备" class="headerlink" title="开始准备"></a>开始准备</h1></blockquote><p>我们需要MySQL的驱动，驱动下载网址：<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">Maven Repository: mysql » mysql-connector-java (mvnrepository.com)</a>(我选的是mysql-connector-java-8.0.X.jar)</p><p><img src="http://img.wcw231407.cn/202403271803631.png" alt="1eeb0dbc027b462da75799eb4c6d6a1e.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403271803700.png" alt="5d5e79085632409d85d966fec7019268.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><h1 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h1></blockquote><p>连接步骤：</p><p><img src="http://img.wcw231407.cn/202403271803129.png" alt="ef189d3228aa4702abdff1ff003bd4f5.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="1-首先需要导入对应数据库的驱动包"><a href="#1-首先需要导入对应数据库的驱动包" class="headerlink" title="1. 首先需要导入对应数据库的驱动包"></a>1. <strong>首先需要导入对应数据库的驱动包</strong></h2><p>要访问MySQL时间就必须要用到MySQL驱动包(前面已经给出了链接)，下载然后导入即可。本例用的是IDEA导入这个jar包</p><p>导包步骤： 点击当前项目左上角File—&gt;Project Structur—&gt;Modules—&gt;点击右边＋号—&gt;Jars Or directories:</p><p><img src="http://img.wcw231407.cn/202403271803505.png" alt="b2f2b7d1501d4b75a4933f0c1855e2e0.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="2-加载驱动"><a href="#2-加载驱动" class="headerlink" title="2.加载驱动"></a><strong>2.加载驱动</strong></h2><p>驱动的加载我们一般使用反射<code>Class.forName(“com.mysql.jdbc.Driver”)</code>来加载Driver这个类(因为它只会创建一次)。也可以使用 <code>DriverManager.registerDriver(new Driver())</code>来加载，但这种方式会new两个Driver,从而造成资源浪费，所以不推荐使用这种方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-写用户信息与url"><a href="#3-写用户信息与url" class="headerlink" title="3.写用户信息与url"></a>3.写用户信息与url</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=ture&amp;useSSL=ture&quot;;</span><br><span class="line">String username=&quot;root&quot;;</span><br><span class="line">Strng password=&quot;123456&quot;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="4-与数据库建立连接"><a href="#4-与数据库建立连接" class="headerlink" title="4.与数据库建立连接"></a>4.与数据库建立连接</h2><p>建立连接需要我们提供上面三个参数，url、username和password</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection con=DriverManager.getConnection(url,username,password);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>各自的参数的含义依次如下：</p><ul><li>协议：jdbc</li><li>子协议：mysql</li><li>数据库服务端的IP地址：localhost或127.0.0.1</li><li>数据库端口：3306</li><li>连接的数据库名称：jdbcstudy</li><li>编码格式：?characterEncoding&#x3D;UTF-8</li><li>数据库用户名：root</li><li>数据库密码：123456（数据库密码是你安装时设置的密码）</li></ul><h2 id="5-创建sql对象，并执行sql"><a href="#5-创建sql对象，并执行sql" class="headerlink" title="5.创建sql对象，并执行sql"></a>5.创建sql对象，并执行sql</h2><ul><li><h3 id="使用Statement执行语句"><a href="#使用Statement执行语句" class="headerlink" title="使用Statement执行语句"></a>使用Statement执行语句</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = con.createStatement();</span><br><span class="line">//添加数据</span><br><span class="line">String insert_sql=&quot;insert into t_user(username,password) values (&#x27;张三&#x27;,123456)&quot;;</span><br><span class="line">int count = statement.executeUpdate(insert_sql);</span><br><span class="line">System.out.println(&quot;受影响行数：&quot;+count);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>sql注入问题</p></blockquote><p>使用Statement有一个极大的缺点，会导致SQL注入。当SQL语句的 where 条件后面带有 or 1&#x3D;1 的条件时，数据库会认为是true可以执行的，所以外界可以对数据库进行删、改操作，这样的数据库如同虚设，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbcstudy?characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">Statement statement = con.createStatement();</span><br><span class="line">//删除数据</span><br><span class="line">String id=&quot;1 or 1=1&quot;;</span><br><span class="line">String delete_sql=&quot;delete from t_user where id=&quot;+id;</span><br><span class="line">int count = statement.executeUpdate(delete_sql);</span><br><span class="line">System.out.println(&quot;影响的行数：&quot;+count);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>以上显然会把数据全部删除；</p><ul><li><h3 id="使用PreparedStatement执行语句（防止sql注入问题）"><a href="#使用PreparedStatement执行语句（防止sql注入问题）" class="headerlink" title="使用PreparedStatement执行语句（防止sql注入问题）"></a>使用PreparedStatement执行语句（防止sql注入问题）</h3></li></ul><p>​    与Statement不同的是PrepareStatement中的SQL使用了占位符(也可以执行没有占位符的SQL语句)。“？”在SQL中就起到占位符的作用。这种方式除了避免了Statement拼接字符串的繁琐之外，还能够提高性能。</p><p>​    填入数据使用PreparedStatement实例的setXXX(int parameterIndex, String x)方法，其中第一个参数时索引位置，第二个是传入数据。要主要的PreparedStatement中的索引是从 1开始的，而不是从0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Connection con=null;</span><br><span class="line">PreparedStatement ps=null;</span><br><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbcstudy?characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;);</span><br><span class="line">    String sql=&quot;insert into t_user(username,password) values (?,?)&quot;;</span><br><span class="line">    ps=con.prepareStatement(sql);</span><br><span class="line">    ps.setString(1,&quot;威哥&quot;);</span><br><span class="line">    ps.setString(2,&quot;123456&quot;);</span><br><span class="line">    int count = ps.executeUpdate();</span><br><span class="line">    System.out.println(&quot;受影响行数：&quot;+count);</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="6-遍历出结果（注意这是执行查询操作时的步骤）"><a href="#6-遍历出结果（注意这是执行查询操作时的步骤）" class="headerlink" title="6.遍历出结果（注意这是执行查询操作时的步骤）"></a>6.遍历出结果（注意这是执行查询操作时的步骤）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Connection con=null;</span><br><span class="line">PreparedStatement ps=null;</span><br><span class="line">ResultSet rs=null;</span><br><span class="line">try &#123;</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/jdbcstudy?characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;);</span><br><span class="line">    String sql=&quot;select * from t_user where username like ?&quot;;//查询SQL</span><br><span class="line">    ps= con.prepareStatement(sql);</span><br><span class="line">    ps.setString(1,&quot;张&quot;+&quot;%&quot;);//查询条件</span><br><span class="line">    rs = ps.executeQuery();////通过PreparedStatement对象调用executeQuery方法，执行sql语句，返回一个ResultSet对象</span><br><span class="line">    while (rs.next())&#123;//相当于一个指针，开始指向整个结果集第一行数据之前，每调用一次就向后移动一次，若没有数据就返回false。</span><br><span class="line">        int id=rs.getInt(1);//用索引</span><br><span class="line">        String username=rs.getString(&quot;username&quot;);//用字段名</span><br><span class="line">        String password=rs.getString(&quot;password&quot;);</span><br><span class="line">        System.out.print(&quot;编号：&quot;+id+&quot;;&quot;);</span><br><span class="line">        System.out.print(&quot;姓名：&quot;+username+&quot;;&quot;);</span><br><span class="line">        System.out.print(&quot;密码：&quot;+password+&quot;;&quot;);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>第一次执行next()后，它指向第一行结果，继续执行next()，他会继续指向下一行</p><p>next的返回结果是布尔值，它可以用来判断是否有下一行。ResultSet中常用的方法在前面第二点已经给出来了，可自行划上去瞄一眼</p><h2 id="7-关闭连接"><a href="#7-关闭连接" class="headerlink" title="7.关闭连接"></a><strong>7.关闭连接</strong></h2><p>对数据库的操作完成后，一定要关闭连接，因为数据库连接非常的耗资源。顺序是后创建的先关闭，这些对象通常是ResultSet, Statement和Connection。</p><p>而且还要在关闭语句中加try catch已经以防止前面关闭出错，导致后面的关闭不了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">finally &#123;</span><br><span class="line">    if (rs!=null)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            rs.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ps != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (con != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><p>常用Statement方法：</p><ul><li><ul><li>execute(String sql):运行语句，返回是否有结果集</li></ul></li><li>executeQuery(String sql)：运行select语句，返回ResultSet结果集。</li><li>executeUpdate(String sql)：运行insert&#x2F;update&#x2F;delete操作，返回更新的行数。</li><li>addBatch(String sql) ：把多条sql语句放到一个批处理中。</li><li>executeBatch()：向数据库发送一批sql语句执行。</li></ul><p>ResultSet接口</p><p>ResultSet提供检索不同类型字段的方法，常用的有：</p><ul><li><ul><li>getString(int index)、getString(String columnName)：获得在数据库里是varchar、char等类型的数据对象。</li></ul></li><li>getFloat(int index)、getFloat(String columnName)：获得在数据库里是Float类型的数据对象。</li><li>getDate(int index)、getDate(String columnName)：获得在数据库里是Date类型的数据。</li><li>getBoolean(int index)、getBoolean(String columnName)：获得在数据库里是Boolean类型的数据。</li><li>getObject(int index)、getObject(String columnName)：获取在数据库里任意类型的数据。</li></ul><p>ResultSet还提供了对结果集进行滚动的方法：</p><ul><li><ul><li>next()：移动到下一行</li></ul></li><li>Previous()：移动到前一行</li><li>absolute(int row)：移动到指定行</li><li>beforeFirst()：移动resultSet的最前面。</li><li>afterLast() ：移动到resultSet的最后面</li></ul><p>使用后依次关闭对象及连接：ResultSet → Statement → Connection</p><hr>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性——StreamAPI</title>
      <link href="/2024/03/27/java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94StreamAPI/"/>
      <url>/2024/03/27/java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94StreamAPI/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 说明：</p><p>java8中有两大最为重要的改变。第一个是Lambda表达式；另外一个则是Stream API。</p><p>Stream API（java.util.stream）把真正的函数式编程风格引入java。这是目前为止对java类库最好的补充，因为Stream API可以极大提供java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream是java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API对集合数据进行操作，就类似于使用sql执行的数据库查询。也可以使用Stream API并执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方式</p></blockquote><blockquote><p> <strong>为什么使用Stream API？</strong></p><p>实际开发中，项目中多数数据源来自于Mysql、Oracle等。但现在数据源可以更多了，有mondb，redis等，而这些NoSql的数据就需要jaav层面去处理。</p><p> <strong>什么是Stream？</strong></p><p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列</p><p> <strong>Stream和Collection集合区别？</strong></p><p>1.Collection是一种静态的内存数据结构，讲的是数据，而Stream是有关计算的，讲的是计算。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算。</p><p>2.Stream API关注的是多个数据的计算（排序、查找、过滤、映射、遍历等）</p><p>3.集合关注的是数据的存储，面向内存的</p><p> <strong>使用说明？</strong></p><p>1.Stream自己不会存储元素。（针对数据计算）</p><p>2.Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</p><p>3.Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。</p><p>4.Stream一旦执行了终止操作，就不能再调用其它中间操作或终终止操作了~</p></blockquote><blockquote><p> 操作步骤</p><ol><li>Stream的实例化</li><li>一系列的中间操作</li><li>执行终止操作</li></ol></blockquote><p>数据准备：</p><p>创建Employee类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package data;</span><br><span class="line">import com.oracle.webservices.internal.api.databinding.DatabindingMode;</span><br><span class="line">public class Employee &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double salary;</span><br><span class="line">    public Employee(long id,String name,int age,double salary)&#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getSalary() &#123;</span><br><span class="line">        return salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSalary(double salary) &#123;</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;Employee&#123;&quot;+&quot;id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age+&quot;,salary=&quot;+salary+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>创建EmployeeData类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package data;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class EmployeeData &#123;</span><br><span class="line">    public static List&lt;Employee&gt; getEmployees()&#123;</span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Employee(1001,&quot;马化腾&quot;,34,6000.38));</span><br><span class="line">        list.add(new Employee(1002,&quot;马云&quot;,2,9876.38));</span><br><span class="line">        list.add(new Employee(1003,&quot;刘强东&quot;,33,3000.82));</span><br><span class="line">        list.add(new Employee(1004,&quot;雷军&quot;,26,7657.37));</span><br><span class="line">        list.add(new Employee(1005,&quot;李彦宏&quot;,65,5555.38));</span><br><span class="line">        list.add(new Employee(1006,&quot;比尔盖茨&quot;,42,9500.38));</span><br><span class="line">        list.add(new Employee(1007,&quot;任正非&quot;,34,4333.32));</span><br><span class="line">        list.add(new Employee(1008,&quot;扎克伯格&quot;,35,2500.32));</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img.wcw231407.cn/202403270955463.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="1-创建Stream（三种方式）"><a href="#1-创建Stream（三种方式）" class="headerlink" title="1.创建Stream（三种方式）"></a>1.创建Stream（三种方式）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package streamTest;</span><br><span class="line"></span><br><span class="line">import data.Employee;</span><br><span class="line">import data.EmployeeData;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.IntStream;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">public class StreamAPITest &#123;</span><br><span class="line">    //创建Stream方式一：通过集合</span><br><span class="line">    @Test</span><br><span class="line">    public  void test1()&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        //返回一个shuixu</span><br><span class="line">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">        //返回一个并行流</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = list.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line">    //创建Stream方式二：通过数组</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        //调用Arrays类的static&lt;T&gt; Stream&lt;T&gt; stream(T[] array):返回一个流</span><br><span class="line">        Integer[] arr = new Integer[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">        int[] arr1 = new int[]&#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">        IntStream stream1 = Arrays.stream(arr1);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建Stream方式大三：通过Stream的of()</span><br><span class="line">    @Test</span><br><span class="line">    public void text3()&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, &quot;C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="2-一系列的在中间操作"><a href="#2-一系列的在中间操作" class="headerlink" title="2.一系列的在中间操作"></a>2.一系列的在中间操作</h1><p>1.筛选与切片</p><p><img src="http://img.wcw231407.cn/202403270955236.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.映射</p><p><img src="http://img.wcw231407.cn/202403270955372.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.排序</p><p><img src="http://img.wcw231407.cn/202403270955979.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="1-筛选与切片"><a href="#1-筛选与切片" class="headerlink" title="1.筛选与切片"></a>1.筛选与切片</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package streamTest;</span><br><span class="line"></span><br><span class="line">import data.Employee;</span><br><span class="line">import data.EmployeeData;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">public class StreamAPITest1 &#123;</span><br><span class="line">    //1-筛选与切片</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        //filter(Predicate p)——接收Lambda，从流中排除某些元素</span><br><span class="line">       //查询员工表中薪资大于7000的员工信息</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">        stream.filter(emp -&gt; emp.getSalary() &gt; 7000).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        //limit(n)——截断流，使其元素不超过给定数量</span><br><span class="line">        //错误的。因为stream已经执行了终止操作，就不可以在调用其他的中间操作或终止操作了</span><br><span class="line">        // stream.limit(2).forEach(System.out::println);</span><br><span class="line">        list.stream().filter(emp -&gt; emp.getSalary()&gt;7000).limit(2).forEach(System.out::println);</span><br><span class="line">        // skip(n) ——跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，返回一个空流。</span><br><span class="line">        list.stream().skip(5).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：如果stream已经执行了终止操作，不可以在调用其他的中间操作或终止操作</p><h2 id="2-映射"><a href="#2-映射" class="headerlink" title="2.映射"></a>2.映射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//2-映射</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        //map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被映射到每个元素上</span><br><span class="line">        //转换为大写</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);</span><br><span class="line">        //方式一：</span><br><span class="line">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line">        //方式二：</span><br><span class="line">        list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //获取员工姓名长度大于3的员工</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        employees.stream().filter(employee -&gt; employee.getName().length()&gt;3).forEach(System.out::println);</span><br><span class="line">        //获取员工姓名长度大于3的员工的姓名</span><br><span class="line">        employees.stream().filter(employee -&gt; employee.getName().length()&gt;3).map(employee -&gt; employee.getName()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//3-排序</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        //sorted()——自然排序</span><br><span class="line">        Integer[] arr = new Integer[]&#123; 342,3,64,46,7,3,54,65,68&#125;;</span><br><span class="line">        String[] arr1 = new String[]&#123;&quot;GG&quot;,&quot;DD&quot;,&quot;MM&quot;,&quot;SS&quot;,&quot;JJ&quot;&#125;;</span><br><span class="line">        Arrays.stream(arr).sorted().forEach(System.out::println);//arr数组并没有因为升序做调整</span><br><span class="line">        Arrays.stream(arr1).sorted().forEach(System.out::println);//arr数组并没有因为升序做调整</span><br><span class="line">        //因为Employee没有实现Comparable接口，所以报错！</span><br><span class="line">//        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">//        list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //sorted(Comparator com)——定制排序</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        //升序</span><br><span class="line">        list.stream().sorted((e1,e2)-&gt; e1.getAge()- e2.getAge()).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        //降序</span><br><span class="line">        list.stream().sorted((e1,e2)-&gt; e2.getAge()- e1.getAge()).forEach(System.out::println);</span><br><span class="line">        //针对字符串从大到小</span><br><span class="line">        Arrays.stream(arr1).sorted((s1,s2)-&gt;s2.compareTo(s1)).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</p><h1 id="3-终止操作"><a href="#3-终止操作" class="headerlink" title="3.终止操作"></a>3.终止操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package streamTest;</span><br><span class="line"></span><br><span class="line">import data.Employee;</span><br><span class="line">import data.EmployeeData;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 终止操作</span><br><span class="line"> */</span><br><span class="line">public class StreamAPITest2 &#123;</span><br><span class="line">    //1-匹配与查找</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        //是否所有的员工的年龄都大于18</span><br><span class="line">        //allMatch(Predicate p)——检查是否匹配所有元素</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(list.stream().allMatch(emp -&gt; emp.getAge() &gt; 18 ));</span><br><span class="line"></span><br><span class="line">        //是否存在年龄大于18岁的员工</span><br><span class="line">        //anyMatch(Predicate p)——检查是否至少匹配一个元素</span><br><span class="line">        System.out.println(list.stream().anyMatch(emp -&gt; emp.getAge() &gt; 18));</span><br><span class="line"></span><br><span class="line">        //是否存在员工的工资大于10000</span><br><span class="line">        System.out.println(list.stream().anyMatch(emp -&gt; emp.getSalary() &gt; 10000));</span><br><span class="line"></span><br><span class="line">        //findFirst——返回第一个元素</span><br><span class="line">        System.out.println(list.stream().findFirst().get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(list.stream().filter(employee -&gt; employee.getSalary()&gt;7000).count());</span><br><span class="line"></span><br><span class="line">        //max(Comparator c)——返回流中的最大值</span><br><span class="line">        //返回最高工资的员工</span><br><span class="line">        System.out.println(list.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line">        //返回最低的工资</span><br><span class="line">        //方式一：</span><br><span class="line">        System.out.println(list.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())).get().getSalary());</span><br><span class="line">        //方式二：</span><br><span class="line">        System.out.println(list.stream().map(employee -&gt; employee.getSalary()).max((e1,e2)-&gt;Double.compare(e1, e2)).get());</span><br><span class="line"></span><br><span class="line">        //min(Comparator c)——返回流中的最小值</span><br><span class="line">        //返回最低工资的员工</span><br><span class="line">        System.out.println(list.stream().min((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line"></span><br><span class="line">        //forEach(Consumer c)——内部迭代</span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //针对于集合，jdk8中增加了一个遍历的方法</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //归约</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        //reduce（T identity,BinaryOperator）——可以将流中元素反复结合起来，得到一个值。返回T</span><br><span class="line">        //计算1-10的自然数的和</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span><br><span class="line">        System.out.println(list.stream().reduce(0,(x1,x2)-&gt;x1+x2));</span><br><span class="line">        System.out.println(list.stream().reduce(10,(x1,x2)-&gt;x1+x2));</span><br><span class="line"></span><br><span class="line">        //reduce(BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span><br><span class="line">        //计算公司所有员工工资的和</span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(employeeList.stream().map(emp -&gt; emp.getSalary()).reduce((salary1, salary2) -&gt; Double.sum(salary1, salary2)));</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        //collect(Collector c)——将流转换为其他形式。接受一个Collector接口的实现，用于给Stream中的元素做汇总的方法</span><br><span class="line">        //查找工资大于6000的员工，结果返回为一List或Set</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; list1 = list.stream().filter(emp -&gt; emp.getSalary() &gt; 6000).collect(Collectors.toList());</span><br><span class="line">        list1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //按照员工的年龄进行排序，返回到一个新的List中</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;Employee&gt; list2 = list.stream().sorted((e1, e2) -&gt; e1.getAge() - e2.getAge()).collect(Collectors.toList());</span><br><span class="line">        list2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.程序运行中，流Stream只能使用一次，使用后会默认关闭，不能重复使用；重复使用会报错，信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">    at java.util.stream.AbstractPipeline.spliterator(AbstractPipeline.java:343)</span><br><span class="line">    at java.util.stream.Stream.concat(Stream.java:1080)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.在开发过程中，建议使用Stream.of(list)，解决list为null的问题；使用list.stream()之前需要判断list是否为null，避免报错空指针异常(java.lang.NullPointerException)。<br>3.stream流遍历获取的对象是原对象<br>4.stream特性思维导图：</p><p><img src="http://img.wcw231407.cn/202403270955835.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">&gt;  说明：</p><blockquote><p>java8中有两大最为重要的改变。第一个是Lambda表达式；另外一个则是Stream API。</p><p>Stream API（java.util.stream）把真正的函数式编程风格引入java。这是目前为止对java类库最好的补充，因为Stream API可以极大提供java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream是java8中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API对集合数据进行操作，就类似于使用sql执行的数据库查询。也可以使用Stream API并执行操作。简言之，Stream API提供了一种高效且易于使用的处理数据的方式</p></blockquote><blockquote><p> <strong>为什么使用Stream API？</strong></p><p>实际开发中，项目中多数数据源来自于Mysql、Oracle等。但现在数据源可以更多了，有mondb，redis等，而这些NoSql的数据就需要jaav层面去处理。</p><p> <strong>什么是Stream？</strong></p><p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列</p><p> <strong>Stream和Collection集合区别？</strong></p><p>1.Collection是一种静态的内存数据结构，讲的是数据，而Stream是有关计算的，讲的是计算。前者是主要面向内存，存储在内存中，后者主要是面向CPU，通过CPU实现计算。</p><p>2.Stream API关注的是多个数据的计算（排序、查找、过滤、映射、遍历等）</p><p>3.集合关注的是数据的存储，面向内存的</p><p> <strong>使用说明？</strong></p><p>1.Stream自己不会存储元素。（针对数据计算）</p><p>2.Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</p><p>3.Stream操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。即一旦执行终止操作，就执行中间操作链，并产生结果。</p><p>4.Stream一旦执行了终止操作，就不能再调用其它中间操作或终终止操作了~</p></blockquote><blockquote><p> 操作步骤</p><ol><li>Stream的实例化</li><li>一系列的中间操作</li><li>执行终止操作</li></ol></blockquote><p>数据准备：</p><p>创建Employee类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package data;</span><br><span class="line">import com.oracle.webservices.internal.api.databinding.DatabindingMode;</span><br><span class="line">public class Employee &#123;</span><br><span class="line">    private long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private double salary;</span><br><span class="line">    public Employee(long id,String name,int age,double salary)&#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getSalary() &#123;</span><br><span class="line">        return salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSalary(double salary) &#123;</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString()&#123;</span><br><span class="line">        return &quot;Employee&#123;&quot;+&quot;id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age+&quot;,salary=&quot;+salary+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>创建EmployeeData类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package data;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class EmployeeData &#123;</span><br><span class="line">    public static List&lt;Employee&gt; getEmployees()&#123;</span><br><span class="line">        List&lt;Employee&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(new Employee(1001,&quot;马化腾&quot;,34,6000.38));</span><br><span class="line">        list.add(new Employee(1002,&quot;马云&quot;,2,9876.38));</span><br><span class="line">        list.add(new Employee(1003,&quot;刘强东&quot;,33,3000.82));</span><br><span class="line">        list.add(new Employee(1004,&quot;雷军&quot;,26,7657.37));</span><br><span class="line">        list.add(new Employee(1005,&quot;李彦宏&quot;,65,5555.38));</span><br><span class="line">        list.add(new Employee(1006,&quot;比尔盖茨&quot;,42,9500.38));</span><br><span class="line">        list.add(new Employee(1007,&quot;任正非&quot;,34,4333.32));</span><br><span class="line">        list.add(new Employee(1008,&quot;扎克伯格&quot;,35,2500.32));</span><br><span class="line"></span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403270955463.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="1-创建Stream（三种方式）-1"><a href="#1-创建Stream（三种方式）-1" class="headerlink" title="1.创建Stream（三种方式）"></a>1.创建Stream（三种方式）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package streamTest;</span><br><span class="line"></span><br><span class="line">import data.Employee;</span><br><span class="line">import data.EmployeeData;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.IntStream;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">public class StreamAPITest &#123;</span><br><span class="line">    //创建Stream方式一：通过集合</span><br><span class="line">    @Test</span><br><span class="line">    public  void test1()&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        //返回一个shuixu</span><br><span class="line">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">        //返回一个并行流</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = list.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line">    //创建Stream方式二：通过数组</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        //调用Arrays类的static&lt;T&gt; Stream&lt;T&gt; stream(T[] array):返回一个流</span><br><span class="line">        Integer[] arr = new Integer[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">        int[] arr1 = new int[]&#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">        IntStream stream1 = Arrays.stream(arr1);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建Stream方式大三：通过Stream的of()</span><br><span class="line">    @Test</span><br><span class="line">    public void text3()&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(&quot;AA&quot;, &quot;BB&quot;, &quot;C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="2-一系列的在中间操作-1"><a href="#2-一系列的在中间操作-1" class="headerlink" title="2.一系列的在中间操作"></a>2.一系列的在中间操作</h1><p>1.筛选与切片</p><p><img src="http://img.wcw231407.cn/202403270955236.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.映射</p><p><img src="http://img.wcw231407.cn/202403270955372.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.排序</p><p><img src="http://img.wcw231407.cn/202403270955979.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="1-筛选与切片-1"><a href="#1-筛选与切片-1" class="headerlink" title="1.筛选与切片"></a>1.筛选与切片</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package streamTest;</span><br><span class="line"></span><br><span class="line">import data.Employee;</span><br><span class="line">import data.EmployeeData;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line">public class StreamAPITest1 &#123;</span><br><span class="line">    //1-筛选与切片</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        //filter(Predicate p)——接收Lambda，从流中排除某些元素</span><br><span class="line">       //查询员工表中薪资大于7000的员工信息</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">        stream.filter(emp -&gt; emp.getSalary() &gt; 7000).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        //limit(n)——截断流，使其元素不超过给定数量</span><br><span class="line">        //错误的。因为stream已经执行了终止操作，就不可以在调用其他的中间操作或终止操作了</span><br><span class="line">        // stream.limit(2).forEach(System.out::println);</span><br><span class="line">        list.stream().filter(emp -&gt; emp.getSalary()&gt;7000).limit(2).forEach(System.out::println);</span><br><span class="line">        // skip(n) ——跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，返回一个空流。</span><br><span class="line">        list.stream().skip(5).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：如果stream已经执行了终止操作，不可以在调用其他的中间操作或终止操作</p><h2 id="2-映射-1"><a href="#2-映射-1" class="headerlink" title="2.映射"></a>2.映射</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//2-映射</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        //map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被映射到每个元素上</span><br><span class="line">        //转换为大写</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;);</span><br><span class="line">        //方式一：</span><br><span class="line">        list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line">        //方式二：</span><br><span class="line">        list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //获取员工姓名长度大于3的员工</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        employees.stream().filter(employee -&gt; employee.getName().length()&gt;3).forEach(System.out::println);</span><br><span class="line">        //获取员工姓名长度大于3的员工的姓名</span><br><span class="line">        employees.stream().filter(employee -&gt; employee.getName().length()&gt;3).map(employee -&gt; employee.getName()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-排序-1"><a href="#3-排序-1" class="headerlink" title="3.排序"></a>3.排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//3-排序</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        //sorted()——自然排序</span><br><span class="line">        Integer[] arr = new Integer[]&#123; 342,3,64,46,7,3,54,65,68&#125;;</span><br><span class="line">        String[] arr1 = new String[]&#123;&quot;GG&quot;,&quot;DD&quot;,&quot;MM&quot;,&quot;SS&quot;,&quot;JJ&quot;&#125;;</span><br><span class="line">        Arrays.stream(arr).sorted().forEach(System.out::println);//arr数组并没有因为升序做调整</span><br><span class="line">        Arrays.stream(arr1).sorted().forEach(System.out::println);//arr数组并没有因为升序做调整</span><br><span class="line">        //因为Employee没有实现Comparable接口，所以报错！</span><br><span class="line">//        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">//        list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //sorted(Comparator com)——定制排序</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        //升序</span><br><span class="line">        list.stream().sorted((e1,e2)-&gt; e1.getAge()- e2.getAge()).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        //降序</span><br><span class="line">        list.stream().sorted((e1,e2)-&gt; e2.getAge()- e1.getAge()).forEach(System.out::println);</span><br><span class="line">        //针对字符串从大到小</span><br><span class="line">        Arrays.stream(arr1).sorted((s1,s2)-&gt;s2.compareTo(s1)).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：Stream不会改变源对象。相反，他们会返回一个持有结果的新Stream</p><h1 id="3-终止操作-1"><a href="#3-终止操作-1" class="headerlink" title="3.终止操作"></a>3.终止操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package streamTest;</span><br><span class="line"></span><br><span class="line">import data.Employee;</span><br><span class="line">import data.EmployeeData;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Optional;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 终止操作</span><br><span class="line"> */</span><br><span class="line">public class StreamAPITest2 &#123;</span><br><span class="line">    //1-匹配与查找</span><br><span class="line">    @Test</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        //是否所有的员工的年龄都大于18</span><br><span class="line">        //allMatch(Predicate p)——检查是否匹配所有元素</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(list.stream().allMatch(emp -&gt; emp.getAge() &gt; 18 ));</span><br><span class="line"></span><br><span class="line">        //是否存在年龄大于18岁的员工</span><br><span class="line">        //anyMatch(Predicate p)——检查是否至少匹配一个元素</span><br><span class="line">        System.out.println(list.stream().anyMatch(emp -&gt; emp.getAge() &gt; 18));</span><br><span class="line"></span><br><span class="line">        //是否存在员工的工资大于10000</span><br><span class="line">        System.out.println(list.stream().anyMatch(emp -&gt; emp.getSalary() &gt; 10000));</span><br><span class="line"></span><br><span class="line">        //findFirst——返回第一个元素</span><br><span class="line">        System.out.println(list.stream().findFirst().get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(list.stream().filter(employee -&gt; employee.getSalary()&gt;7000).count());</span><br><span class="line"></span><br><span class="line">        //max(Comparator c)——返回流中的最大值</span><br><span class="line">        //返回最高工资的员工</span><br><span class="line">        System.out.println(list.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line">        //返回最低的工资</span><br><span class="line">        //方式一：</span><br><span class="line">        System.out.println(list.stream().max((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())).get().getSalary());</span><br><span class="line">        //方式二：</span><br><span class="line">        System.out.println(list.stream().map(employee -&gt; employee.getSalary()).max((e1,e2)-&gt;Double.compare(e1, e2)).get());</span><br><span class="line"></span><br><span class="line">        //min(Comparator c)——返回流中的最小值</span><br><span class="line">        //返回最低工资的员工</span><br><span class="line">        System.out.println(list.stream().min((e1,e2)-&gt;Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line"></span><br><span class="line">        //forEach(Consumer c)——内部迭代</span><br><span class="line">        list.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //针对于集合，jdk8中增加了一个遍历的方法</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //归约</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        //reduce（T identity,BinaryOperator）——可以将流中元素反复结合起来，得到一个值。返回T</span><br><span class="line">        //计算1-10的自然数的和</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);</span><br><span class="line">        System.out.println(list.stream().reduce(0,(x1,x2)-&gt;x1+x2));</span><br><span class="line">        System.out.println(list.stream().reduce(10,(x1,x2)-&gt;x1+x2));</span><br><span class="line"></span><br><span class="line">        //reduce(BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span><br><span class="line">        //计算公司所有员工工资的和</span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployees();</span><br><span class="line">        System.out.println(employeeList.stream().map(emp -&gt; emp.getSalary()).reduce((salary1, salary2) -&gt; Double.sum(salary1, salary2)));</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        //collect(Collector c)——将流转换为其他形式。接受一个Collector接口的实现，用于给Stream中的元素做汇总的方法</span><br><span class="line">        //查找工资大于6000的员工，结果返回为一List或Set</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">        List&lt;Employee&gt; list1 = list.stream().filter(emp -&gt; emp.getSalary() &gt; 6000).collect(Collectors.toList());</span><br><span class="line">        list1.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        //按照员工的年龄进行排序，返回到一个新的List中</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;Employee&gt; list2 = list.stream().sorted((e1, e2) -&gt; e1.getAge() - e2.getAge()).collect(Collectors.toList());</span><br><span class="line">        list2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>1.程序运行中，流Stream只能使用一次，使用后会默认关闭，不能重复使用；重复使用会报错，信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed</span><br><span class="line">    at java.util.stream.AbstractPipeline.spliterator(AbstractPipeline.java:343)</span><br><span class="line">    at java.util.stream.Stream.concat(Stream.java:1080)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.在开发过程中，建议使用Stream.of(list)，解决list为null的问题；使用list.stream()之前需要判断list是否为null，避免报错空指针异常(java.lang.NullPointerException)。<br>3.stream流遍历获取的对象是原对象<br>4.stream特性思维导图：</p><p><img src="http://img.wcw231407.cn/202403270955835.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> stream </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组快速入门</title>
      <link href="/2024/03/27/%E6%95%B0%E7%BB%84%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/27/%E6%95%B0%E7%BB%84%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是数组？"><a href="#1-什么是数组？" class="headerlink" title="1.什么是数组？"></a>1.什么是数组？</h1><blockquote><p>数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。</p><p>即：数组就是一组数据</p></blockquote><h1 id="2-数组的使用"><a href="#2-数组的使用" class="headerlink" title="2.数组的使用"></a>2.数组的使用</h1><h2 id="使用方式1-动态初始化"><a href="#使用方式1-动态初始化" class="headerlink" title="使用方式1-动态初始化"></a>使用方式1-动态初始化</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><blockquote><p>数据类型 数组名[] &#x3D; new 数据类型[大小]</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *循环输入5个成绩，保存到double数组，并输出</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">//1.创建了一个double数组，大小为5</span><br><span class="line">int source[] = new double[5];</span><br><span class="line">//2.循环输入</span><br><span class="line">//source.length 表示数组的大小/长度</span><br><span class="line">Scanner myscanner = new Scanner(System.in);</span><br><span class="line">for(int i = 0;i&lt;sources.length;i++)&#123;</span><br><span class="line">    System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个元素的值&quot;);</span><br><span class="line">    scores[i] = myScanner.nextDouble();</span><br><span class="line">&#125;</span><br><span class="line">//输出，遍历数组</span><br><span class="line">System.out.println(&quot;==数组的元素/值的情况如下：==&quot;)</span><br><span class="line">for(int i = 0;i &lt;scores.length;i++)&#123;</span><br><span class="line">    System.out.println(&quot;第&quot;+(i+1)+&quot;个元素的值&quot;+scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img.wcw231407.cn/202403270803048.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="使用方式2-动态初始化"><a href="#使用方式2-动态初始化" class="headerlink" title="使用方式2-动态初始化"></a>使用方式2-动态初始化</h2><h3 id="1-先声明数组"><a href="#1-先声明数组" class="headerlink" title="1.先声明数组"></a>1.先声明数组</h3><blockquote><p>语法：数据类型 数组名[];也可以 数据类型[] 数组名；</p><p>int a[];或者int [] a;</p></blockquote><h3 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2.创建数组"></a>2.创建数组</h3><blockquote><p>创建语法：数组名 &#x3D; new 数据类型[大小]；</p><p>a &#x3D; new int[10];</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *循环输入5个成绩，保存到double数组，并输出</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">//1.创建了一个double数组，大小为5</span><br><span class="line">int scores[]; //声明数组，这时scores是null</span><br><span class="line">scores = new double[5]; //分配内存空间，可以存放数据</span><br><span class="line">//2.循环输入</span><br><span class="line">//source.length 表示数组的大小/长度</span><br><span class="line">Scanner myscanner = new Scanner(System.in);</span><br><span class="line">for(int i = 0;i&lt;sources.length;i++)&#123;</span><br><span class="line">    System.out.println(&quot;请输入第&quot;+(i+1)+&quot;个元素的值&quot;);</span><br><span class="line">    scores[i] = myScanner.nextDouble();</span><br><span class="line">&#125;</span><br><span class="line">//输出，遍历数组</span><br><span class="line">System.out.println(&quot;==数组的元素/值的情况如下：==&quot;)</span><br><span class="line">for(int i = 0;i &lt;scores.length;i++)&#123;</span><br><span class="line">    System.out.println(&quot;第&quot;+(i+1)+&quot;个元素的值&quot;+scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403270803967.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="使用方式3-静态初始化"><a href="#使用方式3-静态初始化" class="headerlink" title="使用方式3-静态初始化"></a>使用方式3-静态初始化</h2><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><blockquote><p>语法：数据类型 数组名[] &#x3D; {元素值，元素值，…}</p><p>int[] a &#x3D;{2,3,4,5,6,7,8}</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Array02 &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        double[] hens = &#123;3,5,1,3,4,2&#125;;</span><br><span class="line">        for(double hen : hens)&#123;</span><br><span class="line">            System.out.println(hen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403270803105.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>1.数组是多个相同类型数据的组合，实现对这些数据的统一管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//1.数组是多个相同类型数据的组合，实现对这些数据的统一管理 </span><br><span class="line">int[] arr1 = &#123;1,2,3,4,60,1.1&#125;;//double=&gt;int;由于不是自动类型转换;错</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.数组中的元素可以是任何数据类型，包括基本数据类型和引用类型，但是不能混用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//2.数组中的元素可以是任何数据类型，包括基本数据类型和引用类型，但是不能混用 </span><br><span class="line">String[] arr3 = &#123;&quot;北京&quot;,&quot;烤鸭&quot;,&quot;好吃&quot;&#125;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.数组创建后，如果没有赋值，有默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//3.数组创建后，如果没有赋值，有默认值 </span><br><span class="line">//int 0、short 0、byte 0、long 0</span><br><span class="line">//float 0.0、double 0.0、char \u0000、boolean false、String null </span><br><span class="line">short[] arr4 = new short[3];</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4.数组的下标必须是0开始</p><p>5.数组下标必须在指定的范围内使用，否则报：下标越界异常</p><p>6.数组属引用类型，数组型数据是对象</p></blockquote><h1 id="3-数组的赋值机制"><a href="#3-数组的赋值机制" class="headerlink" title="3.数组的赋值机制"></a>3.数组的赋值机制</h1><blockquote><p>数组在默认情况下是引用类型，赋的值是地址</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//基本数据类型赋值，赋值方式为值（拷贝）</span><br><span class="line">//n2的变化，不影响到n1的值</span><br><span class="line">int n1 = 10;</span><br><span class="line">int n2 = n1;</span><br><span class="line">n2 = 80;</span><br><span class="line">//数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传递</span><br><span class="line">//是一个地址，arr2变化会影响到arr1</span><br><span class="line">int[] arr1 = &#123;1, 2, 3&#125;;</span><br><span class="line">int[] arr2 = arr1;</span><br><span class="line">arr2[0] = 10;</span><br><span class="line">System.out.println(arr1[0]);</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403270803785.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="值传递与引用传递的区别？"><a href="#值传递与引用传递的区别？" class="headerlink" title="值传递与引用传递的区别？"></a>值传递与引用传递的区别？</h2><blockquote><p>值传递：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//n2的变化，不影响到n1的值 </span><br><span class="line">int n1 = 10; </span><br><span class="line">int n2 = n1; </span><br><span class="line">n2 = 80;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403270803844.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//是一个地址，arr2变化会影响到arr1 </span><br><span class="line">int[] arr1 = &#123;1, 2, 3&#125;; </span><br><span class="line">int[] arr2 = arr1; </span><br><span class="line">arr2[0] = 10;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403270803157.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="4-数组的拷贝"><a href="#4-数组的拷贝" class="headerlink" title="4.数组的拷贝"></a>4.数组的拷贝</h1><blockquote><p>实现数组的拷贝（内容的复制）</p><p>将int[] arr1 &#x3D; {10,20,30};拷贝到arr2数组，要求数据空间是独立的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//将int[] arr1 = &#123;10,20,30&#125;;拷贝到arr2数组</span><br><span class="line">// 要求数据空间是独立的</span><br><span class="line">int arr[] = &#123;10,20,30&#125;;</span><br><span class="line">//创建一个新的数组arr2，开辟一个新的数据空间</span><br><span class="line">//大小 arr1.length;</span><br><span class="line">int[] arr2 =new int[arr.length];</span><br><span class="line">//遍历arr1，把每一个元素拷贝到对应的位置</span><br><span class="line">for(int i = 0; i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr2[i] = arr[i];</span><br><span class="line">    System.out.println(arr2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>解析：</p><p>int[] arr2 &#x3D;new int[arr.length];在堆中重新创建了一个空间，这时使用的空间与arr不一样，也就是使它们的空间内存独立了如图：</p><p><img src="http://img.wcw231407.cn/202403270803506.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象内存与方法调用机制</title>
      <link href="/2024/03/26/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/03/26/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E4%B8%8E%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><blockquote><p>对象、字符串和数组都是引用类型，指向的数</p></blockquote><p>我们以下面main方法部分代码片段为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.name = &quot;小白&quot;;</span><br><span class="line">cat.age = 12;</span><br><span class="line">cat.color = &quot;白色&quot;;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403262113166.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>首先执行mian方法，会在栈里创建一个独立的main栈空间（这里说成main栈是为了便于区分栈），在执行Cat cat &#x3D; new Cat()，执行完后会在堆中产生一个对象空间，cat指向该对象空间，cat的基本类型age数据会直接存到堆信息中，由于name，color是字符串所以会在方法区中常量池在开创一个空间，用来存储他们的数据，此时堆中name与color指向该空间地址</p><p>注：当new一个对象时会加载Cat类的属性信息和行为（方法信息）</p></blockquote><p>我们以下面代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Persion p1 = new Persion();</span><br><span class="line">p1.age = 10;</span><br><span class="line">p1.name = &quot;小明&quot;;</span><br><span class="line">Persion p2 = p1; //把p1赋给了p2，让p2指向p1</span><br><span class="line">System.out.println(p2.age)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>内存图：</p><p><img src="http://img.wcw231407.cn/202403262113252.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>当我们new一个p1对象时，在堆中会创建一个内存空间，此时p1指向创建好的内存空间，如果属性信息是引用类型则数据会存到方法区，而栈里面的该属性内存地址存放的就是具体数据的地址，在执行Persion p2 &#x3D; p1，会p2直接指向p1指向的内存空间。</p></blockquote><blockquote><p>java内存结构分析：</p><p>1.栈：一般存放基本数据类型（局部变量）</p><p>2.堆：存放对象（Cat cat，数组等）</p><p>3.方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><h1 id="方法调用机制"><a href="#方法调用机制" class="headerlink" title="方法调用机制"></a>方法调用机制</h1><p>我们以一下面代码段为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Persion();</span><br><span class="line">int returnRes = p1.getSum(10,20);</span><br><span class="line"></span><br><span class="line">//getSun(10,20)方法</span><br><span class="line">public int getSum(int num1,int num2)&#123;</span><br><span class="line">    int res = num1 +num2;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403262113292.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>首先main方法执行时，会在栈中创建一个main栈空间，在执行Person p1 &#x3D; new Persion();执行完后会有一个对象空间产生，p1指向该对象空间，然后在执行int returnRes &#x3D; p1.getSum(10,20);执行完后会在开一个栈空间（getSum栈独立空间，这里叫getSum栈便于区分栈空间），然后将10赋值给num1，将20赋值给num2，res就等于30，在执行return语句，将结果返回到int returnRes &#x3D; p1.getSum(10,20)这个位置即返回给returnRes，当main方法结束后，整个程序退出（遵循栈的先进后出原则）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 对象内存 </tag>
            
            <tag> 方法调用机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域基本使用</title>
      <link href="/2024/03/26/%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/26/%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 基本使用</p><p>​    1.在java编程中，主要的变量就是属性（成员变量）和局部变量</p><p>​    2.局部变量一般指的是在成员方法中定义的变量</p><p>​    3.java中作用域的分类</p><p>​        全局变量：也就是属性，作用域为整个类体</p><p>​        局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中</p><p>​    4.全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class VarScope &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.cry();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat&#123;</span><br><span class="line">    //全局变量：也就是属性，作用域为整个类体Cat类：cry eat等方法使用属性</span><br><span class="line">    int age = 10;</span><br><span class="line">    public void cry()&#123;</span><br><span class="line">        //1.局部变量一般是指在成员方法中定义的变量</span><br><span class="line">        //2.n 和 name 就是局部变量</span><br><span class="line">        //3.n 和 name的作用域在cry 方法中</span><br><span class="line">        int n = 10;</span><br><span class="line">        String name = &quot;jack&quot;;</span><br><span class="line">        System.out.println(&quot;cry中使用age=&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;在eat中使用属性age=&quot;+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403262106103.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p> 注意事项和使用细节1：</p><p>​    1.属性和局部变量可以重名，访问时遵循就近原则。</p><p>​    2.在同一个作用域域中，比如在同一个成员方法中，两个局部变量，不能重名。</p><p>​    3.属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随代码块的结束而死亡，即在一次方法调用过程中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class VarScopeDetail &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Person p1 = new Person();</span><br><span class="line">        /*</span><br><span class="line">        属性生命周期较长，伴随着对象的创建而创建，伴随着对象的死亡而死亡。</span><br><span class="line">        局部变量，生命周期较短，伴随着它的代码块的执行而创建，</span><br><span class="line">        伴随代码块的结束而死亡，即在一次方法调用过程中。</span><br><span class="line">         */</span><br><span class="line">        p1.say();//当执行say方法时，say方法的局部变量比如name，会创建，当say执行完毕后name就会销毁</span><br><span class="line">        //属性（全局变量）仍然可以使用</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    String name = &quot;jack&quot;;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        //属性和局部变量可以重名，访问时遵循就近原则</span><br><span class="line">        String name = &quot;king&quot;;</span><br><span class="line">        System.out.println(&quot;say() name=&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403262106021.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>注意事项和使用细节2：</p><p>​    4.作用域范围不同</p><p>​      全局变量&#x2F;属性：可以被本类使用，或其他类使用（通过对象调用）</p><p>​      局部变量：只能在本类中对应的方法中使用</p><p>​    5.修饰符不同</p><p>​       全局变量&#x2F;属性可以加修饰符</p><p>​       局部变量不可以加修饰符</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class VarScopeDetail &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Person p1 = new Person();</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        t1.test();//第一种跨类访问对象属性的方式</span><br><span class="line">        t1.test2(p1);//第二种方式跨类访问对象属性的方式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class T &#123;</span><br><span class="line">    //全局变量/属性：可以被本类使用，或其他类使用（通过对象调用）</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        Person p1 = new Person();</span><br><span class="line">        System.out.println(p1.name);</span><br><span class="line">    &#125;</span><br><span class="line">    public void test2(Person p)&#123;</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Person &#123;</span><br><span class="line">    //属性可以加修饰符（public protected private..）</span><br><span class="line">    //    局部变量不能加修饰符</span><br><span class="line">    private int age = 20;</span><br><span class="line">    String name = &quot;jack&quot;;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        //属性和局部变量可以重名，访问时遵循就近原则</span><br><span class="line">        String name = &quot;king&quot;;</span><br><span class="line">        System.out.println(&quot;say() name=&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403262106157.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java使用规范</title>
      <link href="/2024/03/26/java%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
      <url>/2024/03/26/java%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p><strong>1.关键字</strong></p><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串(单词)</p><p>特点：关键字中的所有字母都是小写</p><p><strong>2.保留字</strong></p><p>java保留字：现有<img src="http://img.wcw231407.cn/284301a4042d4cebadb9ac4d7aa1c3d2.png" alt="Java版本">尚未使用，但以后的版本可能会作为关键字使用。命名标识符时要避免使用这些保留字</p><p>goto 、const</p><p><strong>2.标识符(Identifier)</strong></p><p>（不遵守规则下列时，编译不能通过）</p><ul><li>Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li><li>技巧：凡是自己可以起名字的地方都叫标识符。</li></ul><p>比如：类名，变量名，方法名，接口名，包名。</p><ul><li>定义合法标识符规则:</li></ul><p>1.由26个英文字母大小写，0-9，_或$组成</p><p>2.数字不可以开头。</p><p>3.不可以使用关键字和保留字，但能包含关键字和保留字。</p><p>4.Java中严格区分大小写，长度无限制。</p><p>5.标识符不能包含空格。</p><p><strong>4.Java中的名称命名规范：</strong></p><p>（不遵守时，可以通过编译）</p><ul><li>包名：多单词组成时所有字母都小写：xxxyyyzzz</li><li>类名、接口名：每个单词首字母大写：XxxYyyZzz</li><li>方法和变量：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2024/03/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/03/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a><strong>TCP与UDP</strong></h1><ul><li><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h2></li></ul><p><strong>1.传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据流量控制等功能，保证数据能从一端传到另一端。</strong></p><blockquote><p>tcp连接就像打电话，两者之间必须有一条不间断的通路，数据不到达对方，对方就一直在等待，除非对方直接挂电话。先说的话先到，后说的话后到，有顺序。</p></blockquote><ul><li><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><strong>UDP</strong></h2></li></ul><p><strong>2.用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</strong></p><blockquote><p>udp就象寄一封信，发信者只管发，不管到。但是你的信封上必须写明对方的地址。发信者和收信者之间没有通路，靠邮电局联系。信发到时可能已经过了很久，也可能根本没有发到。先发的信未必先到，后发的也未必后到。</p></blockquote><ul><li><h2 id="TUP与UDP的区别"><a href="#TUP与UDP的区别" class="headerlink" title="TUP与UDP的区别"></a><strong>TUP与UDP的区别</strong></h2></li></ul><p>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</p><p>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</p><p>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</p><p>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p><p>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节</p><p>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p><blockquote><p>说到TCP和UDP,首先要明白“连接”和“无连接”的含义，他们的关系可以用一个形象地比喻来说明，就是打电话和写信。</p><p>两个人如果要通话，首先要建立连接——即打电话时的拨号，等待响应后——即接听电话后，才能相互传递信息，最后还要断开连接——即挂电话。</p><p>写信就比较简单了，填写好收信人的地址后将信投入邮筒，收信人就可以收到了。</p><p>从这个分析可以看出，建立连接可以在需要痛心地双方建立一个传递信息的通道，在发送方发送请求连接信息接收方响应后，由于是在接受方响应后才开始传递信息，而且是在一个通道中传送，因此接受方能比较完整地收到发送方发出的信息，即信息传递的可靠性比较高。但也正因为需要建立连接，使资源开销加大（在建立连接前必须等待接受方响应，传输信息过程中必须确认信息是否传到及断开连接时发出相应的信号等），独占一个通道，在断开连接钱不能建立另一个连接，即两人在通话过程中第三方不能打入电话。而无连接是一开始就发送信息（严格说来，这是没有开始、结束的），只是一次性的传递，是先不需要接受方的响应，因而在一定程度上也无法保证信息传递的可靠性了，就像写信一样，我们只是将信寄出去，却不能保证收信人一定可以收到。</p></blockquote><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a><strong>TCP&#x2F;IP</strong></h1><p>传输控制协议&#x2F;因特网互联协议，也叫网络通信协议，是internet最基本的协议，简单地说就是网络层的IP协议与传输层的TCP协议。</p><blockquote><p>IP：网络中每台计算机的标识号，本地IP为127.0.0.1 localhost</p><p>端口号：范围0-65535之间，0-1023之间的端口数用于一些知名的网络服务与应用，依我之                           见，端口就是一个虚拟的门可以访问到指定的服务与应用</p><p>IP+端口号就是套接字</p></blockquote><h1 id="网络编程中的TCP协议"><a href="#网络编程中的TCP协议" class="headerlink" title="网络编程中的TCP协议"></a><strong>网络编程中的TCP协议</strong></h1><ul><li><strong>服务端与客户端进行通信</strong></li></ul><blockquote><p>Soket：网络驱动层提供给应用程序编程的接口和一种机制</p><p>端口号拼接到IP地址即构成套接字</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*服务端</span><br><span class="line">*/</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">public class EchoServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">        //服务器地址</span><br><span class="line">        ServerSocket server = new ServerSocket(6666);</span><br><span class="line">        System.out.println(&quot;服务器已启动，等待连接---&quot;);</span><br><span class="line">        //等待客户端连接</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        System.out.println(&quot;客户端连接成 </span><br><span class="line">        功&quot;+server.getInetAddress().getHostAddress());</span><br><span class="line">        //读取客户端消息</span><br><span class="line">        BufferedReader br=new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">        String info =br.readLine();</span><br><span class="line">        System.out.println(info);</span><br><span class="line">        //给客户端发送消息</span><br><span class="line">        PrintStream ps = new PrintStream(new</span><br><span class="line">        BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line">        ps.println(&quot;echo:&quot;+info);</span><br><span class="line">        ps.flush();</span><br><span class="line">        ps.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">*客户端</span><br><span class="line">*/</span><br><span class="line">import java.io.*;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.Locale;</span><br><span class="line">public class EchoClientDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        //创建一个Socket连接</span><br><span class="line">        Socket socket = new Socket(InetAddress.getLocalHost(),6666);</span><br><span class="line">        //发送消息IO流</span><br><span class="line">        PrintStream ps =new PrintStream(</span><br><span class="line">        new BufferedOutputStream(socket.getOutputStream()));</span><br><span class="line">        BufferedReader br=new BufferedReader(</span><br><span class="line">        new InputStreamReader(socket.getInputStream()));</span><br><span class="line">        ps.println(&quot;我是你威哥&quot; );</span><br><span class="line">         //接收服务器输出的消息   </span><br><span class="line">        String info=br.readLine();</span><br><span class="line">        System.out.println(info);</span><br><span class="line">        ps.close();</span><br><span class="line">        br.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>服务器同时处理多个客户端</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">public class ServerDemo &#123;</span><br><span class="line">    public static void  main(String[] args)&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(3);</span><br><span class="line">        try &#123;</span><br><span class="line">            ServerSocket server =new ServerSocket(6666);</span><br><span class="line">            System.out.println(&quot;服务器等待连接---&quot;);</span><br><span class="line">            while(true)&#123;</span><br><span class="line">                Socket s=server.accept();</span><br><span class="line">                System.out.println(s.getInetAddress().getHostAddress());</span><br><span class="line">                es.execute(new UserThread(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class UserThread implements Runnable&#123;</span><br><span class="line">    private Socket s;</span><br><span class="line">    public UserThread(Socket s)&#123;</span><br><span class="line">        this.s=s;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));</span><br><span class="line">            PrintStream ps =new PrintStream(new BufferedOutputStream(s.getOutputStream()));</span><br><span class="line">            String info=br.readLine();</span><br><span class="line">            System.out.println(info);</span><br><span class="line">            ps.println(&quot;echo:&quot;+info);</span><br><span class="line">            ps.flush();</span><br><span class="line">            ps.close();</span><br><span class="line">            br.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="初识Tomcat"><a href="#初识Tomcat" class="headerlink" title="初识Tomcat"></a><strong>初识Tomcat</strong></h1><p>服务端</p><ul><li>自定义（s）</li><li>Tomcat服务器（s）:java后台开发</li></ul><p>客户端</p><ul><li>自定义（c）</li><li>浏览器（s）</li></ul><blockquote><p>它有webapps文件，可以像宝塔面板一样创建自己的网站</p></blockquote></li></ul><h1 id="网络编程UDP协议"><a href="#网络编程UDP协议" class="headerlink" title="网络编程UDP协议"></a><strong>网络编程UDP协议</strong></h1><p><img src="http://img.wcw231407.cn/image-20240326203013224.png" alt="image-20240326203013224"></p><ul><li><strong>服务端</strong></li></ul><p>1.将信息封装为数据报,并指定目标端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String info=&quot;---&quot;</span><br><span class="line">byte[] bytes=info.getBytes();</span><br><span class="line">DatagramPacket dp=new DatagramPacket(bytes,0,bytes.length,</span><br><span class="line">InetAddress.getByName(&quot;127.0.0.1&quot;),6000);</span><br></pre></td></tr></table></figure><p>2.创建套接字对象，并指定服务器端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket=new DatagramSocket(6001);</span><br></pre></td></tr></table></figure><p>3.发送数据报，并关闭套接字对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socket.send(dp);</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><ul><li><strong>客户端</strong></li></ul><p>1.建立一个Socket,开发端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket socket=new DatagramSocket(6000);</span><br></pre></td></tr></table></figure><p>2.接收内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte[] bytes=new byte[1024];</span><br><span class="line">DatagramPacket dp=new DatagramPacket(bytes,0,bytes.length);</span><br></pre></td></tr></table></figure><p>3.阻塞接收,并关闭流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.receive(dp);//阻塞接受数据</span><br><span class="line">String info=new String(dp.getData(),0,dp.getLength);</span><br><span class="line">System.out.println(info);</span><br><span class="line">socket.close();//关闭流</span><br></pre></td></tr></table></figure><p>接受端</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.*;</span><br><span class="line"></span><br><span class="line">public class UDPServerDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws RuntimeException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String info=&quot;good good study,day day up&quot;;</span><br><span class="line">            byte[] bytes=info.getBytes();</span><br><span class="line">            DatagramPacket dp = new DatagramPacket(bytes,0,bytes.length, </span><br><span class="line">            InetAddress.getByName(&quot;127.0.0.1&quot;),5000);</span><br><span class="line">            DatagramSocket    socket = new DatagramSocket(6001);</span><br><span class="line">            socket.send(dp);</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; catch (SocketException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;catch (UnknownHostException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送端</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line">public class UDPClientDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        byte[] bytes=new byte[1024];</span><br><span class="line">       DatagramPacket dp=new DatagramPacket(bytes,bytes.length);</span><br><span class="line">        try&#123;</span><br><span class="line">        DatagramSocket ds=new DatagramSocket(5000);</span><br><span class="line">        System.out.println(&quot;正在连接---&quot;);</span><br><span class="line">        ds.receive(dp);</span><br><span class="line">        System.out.println(&quot;连接成功&quot;);</span><br><span class="line">        String info=new String(dp.getData(),0, dp.getLength());</span><br><span class="line">        System.out.println(info);</span><br><span class="line">            ds.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象-01</title>
      <link href="/2024/03/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-01/"/>
      <url>/2024/03/26/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-01/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a><strong>对象的内存布局</strong></h1><p>对象、字符串和数组都是引用类型，指向的数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.name = &quot;小白&quot;;</span><br><span class="line">cat.age = 12;</span><br><span class="line">cat.color = &quot;白色&quot;;</span><br></pre></td></tr></table></figure><p><img src="http://img.wcw231407.cn/202403261836178.png" alt="image-20240326183642090"></p><p>对象名和地址会存到栈信息中，cat的基本类型age数据会直接存到堆信息中，由于name，color是字符串所以地址会存到栈信息，而存到栈里面的地址会指向方法区</p><p>当new一个对象时会加载Cat类的属性信息和行为（方法信息）</p><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a><strong>类与对象</strong></h1><h2 id="属性-成员变量"><a href="#属性-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a><strong>属性&#x2F;成员变量</strong></h2><p>成员变量&#x3D;属性&#x3D;fieId（成员变量是用来表示属性的）</p><p>属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象，数组）</p><p>注意细节：</p><p>1.属性的定义语法同变量，但是属性可以带上访问修饰符【访问修饰符 属性类型 属性名；】</p><p>2.属性如果不赋值，有默认值，规则和数组一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//int 0、short 0、byte 0、long 0</span><br><span class="line">//float 0.0、double 0.0、char \u0000、boolean false、String null</span><br></pre></td></tr></table></figure><h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a><strong>访问属性</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//第一种创建对象</span><br><span class="line">//先声明在创建</span><br><span class="line">Cat cat;//声明对象cat</span><br><span class="line">cat = new Cat();//创建</span><br><span class="line">//第二种创建</span><br><span class="line">//直接创建</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">//访问属性</span><br><span class="line">//对象名.属性名;</span><br><span class="line">cat.name;</span><br><span class="line">cat.age;</span><br><span class="line">cat.color;</span><br></pre></td></tr></table></figure><h2 id="类和对象的内存分配机制"><a href="#类和对象的内存分配机制" class="headerlink" title="类和对象的内存分配机制"></a><strong>类和对象的内存分配机制</strong></h2><p>我们以下面代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Persion p1 = new Persion();</span><br><span class="line">p1.age = 10;</span><br><span class="line">p1.name = &quot;小明&quot;;</span><br><span class="line">Persion p2 = p1; //把p1赋给了p2，让p2指向p1</span><br><span class="line">System.out.println(p2.age)</span><br></pre></td></tr></table></figure><p>内存图：</p><p><img src="http://img.wcw231407.cn/202403261832246.png" alt="image-20240326183231192"></p><p>但我们new一个p1对象时，在堆中会创建一个内存空间并存储属性与方法相关的信息，并把对象地址信息加载到栈信息当中指向创建好的内存空间，如果属性信息是引用类型则数据会存到方法区，而栈里面的该属性内存地址存放的就是数据的地址</p><p>java内存结构分析：</p><p>1.栈：一般存放基本数据类型（局部变量）</p><p>2.堆：存放对象（Cat cat，数组等）</p><p>3.方法区：常量池（常量，比如字符串），类加载信息</p><h1 id="方法调用机制"><a href="#方法调用机制" class="headerlink" title="方法调用机制"></a><strong>方法调用机制</strong></h1><p>外面一下面代码段为例：</p><p><img src="http://img.wcw231407.cn/202403261832491.png" alt="image-20240326183104622"></p><p>&#x3D;&#x3D; 首先main方法执行时，会在栈中创建一个main栈空间，在执行Person p1 &#x3D; new Persion();执行完后会有一个对象空间产生，p1指向该对象空间，然后在执行int returnRes &#x3D; p1.getSum(10,20);执行完后会在开一个栈空间（getSum栈独立空间，这里叫getSum栈便于区分栈空间），然后将10赋值给num1，将20赋值给num2，res就等于30，在执行return语句，将结果返回到int returnRes &#x3D; p1.getSum(10,20)这个位置即返回给returnRes，当main方法结束后，整个程序退出（遵循栈的先进后出原则）&#x3D;&#x3D;</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建博客</title>
      <link href="/2024/03/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/03/06/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>本片文章我们主要以hexo来搭建一个属于我们自己的个人博客</p><h1 id="1-在搭建之前我们先了解一下什么是hexo呢？"><a href="#1-在搭建之前我们先了解一下什么是hexo呢？" class="headerlink" title="1.在搭建之前我们先了解一下什么是hexo呢？"></a>1.在搭建之前我们先了解一下什么是hexo呢？</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架！！！</p><blockquote><p>我为什么会选择hexo来搭建博客呢？</p><p>对于小白来说它也是不二之选，对于处于第三方大平台上的我，比较不自由，我个人认为它的界面美观十分优雅，它的搭建成本也低，我们只需一台电脑就可以搭建。</p></blockquote><p>参考链接：<a href="https://youtu.be/PsXWbI2Mqu0">https://youtu.be/PsXWbI2Mqu0</a></p><p>接下我们直接搭建博客！！！ </p><h1 id="2-博客的搭建"><a href="#2-博客的搭建" class="headerlink" title="2. 博客的搭建"></a>2. 博客的搭建</h1><h2 id="nodejs，Git环境搭建"><a href="#nodejs，Git环境搭建" class="headerlink" title="nodejs，Git环境搭建"></a>nodejs，Git环境搭建</h2><p>1.nvm下载参看文章：<a href="https://blog.csdn.net/Anony_me/article/details/124153201">nvm详细安装步骤以及使用（window10系统）_nvm安装教程-CSDN博客</a></p><blockquote><p>nvm是一个管理<a href="https://so.csdn.net/so/search?q=nodejs&spm=1001.2101.3001.7020">nodejs</a>版本的工具。在实际的开发中，有些项目的开发依赖需要低版本的nodejs运行环境，此时我们就需要使用nvm来降低nodejs版本。　</p></blockquote><p> 2.安装nodejs</p><blockquote><p>在cmd命令框中使用以下命令进行安装</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install [version]            // 安装node， version是特定版本也可以是最新稳定版本latest</span><br><span class="line"> nvm list available               // 显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls</span><br><span class="line">nvm ls available                 // 显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls</span><br><span class="line">nvm use &lt;version&gt;                // 切换到使用指定的nodejs版本</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>修改全局安装默认路径</p><p>如下（在cmd命令窗口执行）：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd&gt; npm config set prefix &quot;C:\Users\Administrator\AppData\Roaming\nvm\node_global&quot;</span><br><span class="line">cmd&gt; npm config set cache &quot;C:\Users\Administrator\AppData\Roaming\nvm\node_cache&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p> 将npm镜像改为淘宝的镜像cnpm，可以提高下载速度</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403081023637.png" alt="661b9ac03ba44ab8ae5b4a30dce3d786.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="安装hexo，完成简单的本地页面展示"><a href="#安装hexo，完成简单的本地页面展示" class="headerlink" title="安装hexo，完成简单的本地页面展示"></a>安装hexo，完成简单的本地页面展示</h2><p>1.全局安装 Hexo，进入cmd输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.创建一个文件夹Blog，在这个文件夹下直接右键git bash打开。</p><p><img src="http://img.wcw231407.cn/202403081024447.png" alt="86215837135f402f8e25033d1f2d4a0c.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.接下来初始化一下hexo </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>生成以下目录：</p><p>【node_modules】：依赖包<br> 【scaffolds】：生成文章的一些模板<br> 【source】：用来存放你的文章<br> 【themes】：主题<br> 【.npmignore】：发布时忽略的文件（可忽略）<br> 【_config.landscape.yml】：主题的配置文件<br> 【config.yml】：博客的配置文件<br> 【package.json】：项目名称、描述、版本、运行和开发等信息</p></blockquote><blockquote><p>遇到问题：不能使用hexo命令</p><p>解决分析：</p><p>不能使用hexo命令是因为我们本地电脑找不到hexo.cmd目录路径，这时hexo.cmd在我们自己安装node时设置的全局路径node_global下,只要将hexo.cmd所在目录配置到环境变量就好，具体配置环境变量方法由于简单不过于介绍自己上网搜索即可！！！</p><p>可参考链接：<a href="https://blog.csdn.net/Deng872347348/article/details/121646375">安装hexo时出现的问题：‘hexo‘ 不是内部或外部命令，也不是可运行的程序_hexo’ 不是内部或外部命令,也不是可运行的程序 或批处理文件。-CSDN博客</a></p></blockquote><p> <img src="http://img.wcw231407.cn/202403081024912.png" alt="6b41baddba90482e89e40b5e6424dd4f.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4.改配置</p><p><img src="http://img.wcw231407.cn/202403081025386.png" alt="a636380fd8aa43e58c1cb5c6f03c8332.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> 相关配置：</p><p>网站</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td>网站标题</td></tr><tr><td>subtitle</td><td>网站副标题</td></tr><tr><td>description</td><td>网站描述</td></tr><tr><td>keywords</td><td>网站的关键词。支持多个关键词。</td></tr><tr><td>author</td><td>您的名字</td></tr><tr><td>language</td><td>网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans 和 zh-CN 。</td></tr><tr><td>timezone</td><td>网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 America&#x2F;New_York , Japan , 和 UTC 。一般的，对于中国大陆地区可以使用 Asia&#x2F;Shanghai 。</td></tr></tbody></table><p>各参数代表含义具体参考链接：<a href="https://hexo.io/zh-cn/docs/configuration">配置 | Hexo</a></p><p>5.生成静态文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 6.启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-p,–port</td><td>重设端口</td></tr><tr><td>-s,–static</td><td>只使用静态文件</td></tr><tr><td>-l,–log</td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><p><img src="http://img.wcw231407.cn/boke/%E5%8D%9A%E5%AE%A201.png" alt="成功页面"></p><p>进入以上命令则成功！！！</p><h2 id="注册Git并创建仓库"><a href="#注册Git并创建仓库" class="headerlink" title="注册Git并创建仓库"></a>注册Git并创建仓库</h2><p>1.在git注册一步一步跟着注册流程走</p><p>2.创建仓库格式要求：用户名.github.io</p><p>3.配置用户名和邮箱</p><p>在博客根目录下打开git bash输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="http://img.wcw231407.cn/202403081026722.png" alt="a6a30215d6ce4cff82d30d1c8a029c76.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>4.在博客根目录打开git bash执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="连接至github"><a href="#连接至github" class="headerlink" title="连接至github"></a>连接至github</h1><p>1.执行以下命令生成ssh公钥，此公钥用于你的计算机连接Github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>之后打开C盘下用户文件夹下的.ssh的文件夹，会看到 id_rsa.pub</p><p><img src="http://img.wcw231407.cn/202403081026671.png" alt="7dfd2f82c2f74409b3f7d86a73e3e84a.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><blockquote><p>用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在github中配置ssh密钥。</p></blockquote><p>2.将 SSH KEY 配置到 GitHub</p><blockquote><p>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。</p></blockquote><p> <img src="http://img.wcw231407.cn/202403081026695.png" alt="9e4a6cc3c9784340a7a51865b2682840.png"><br> <img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>3.测试连接，输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作！！！</p><h2 id="将静态博客挂载到-GitHub-Pages"><a href="#将静态博客挂载到-GitHub-Pages" class="headerlink" title="将静态博客挂载到 GitHub Pages"></a>将静态博客挂载到 GitHub Pages</h2><p>1.安装 hexo-deployer-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2.修改 _config.yml 文件</p><blockquote><p>在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。<br> 修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Fomalhaut-Blog/Fomalhaut-Blog.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3.修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo三连） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean    //删除之前生成的文件，若未生成过静态文件，可忽略此命令。</span><br><span class="line"></span><br><span class="line">hexo generate    //生成静态文章，可以用hexo g缩写</span><br><span class="line"></span><br><span class="line">hexo deploy    //部署文章，可以用hexo d缩写</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>查看自己的仓库显示：</p><p><img src="http://img.wcw231407.cn/202403081026974.png" alt="ac336725b5124d1287d9494c6f0d2c9a.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这就表示成功了！！！</p><p>稍等两分钟，打开浏览器访问：https：你的仓库名.gitgub.io ，这时候我们就可以看到博客内容了。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
